#!/bin/bash

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELOW=$(tput setaf 3)
BLUE=$(tput setaf 14)
NC=$(tput sgr 0)

function info() { echo "${BLUE}${@}${NC}"; }
function error() { echo "${RED}${@}${NC}"; }
function success() { echo "${GREEN}${@}${NC}"; }


function get_pluglist () {

  local diff now loadfile
  loadfile=false
  if [ -f "$SCRIPT_DIR"/pluglist.json ]; then
    now=$(date +'%Y-%m-%d')
    [[ $(stat "$SCRIPT_DIR"/pluglist.json | grep -E ^.*Modify:.*$) =~ ^.*Modify:.([0-9]{4}-[0-9]{2}-[0-9]{2}).*$ ]] && filedate="${BASH_REMATCH[1]}"
    let diff=($(date +%s -d "$now") - $(date +%s -d "$filedate"))/86400
    [ "$DEBUG" = true ] && info Diff days: $diff  
    [[ $diff -gt "$DIFF_DAYS" ]] && loadfile=true
  else  
    [ "$DEBUG" = true ] && info loadfile
    loadfile=true
  fi 
  
  [[ $"$loadfile" = true ]] && wget download.moodle.org/api/1.3/pluglist.php -O "$SCRIPT_DIR"/pluglist.json
}

load_cnf () {  
  error=0
  PROJECT="$1"
  [ "$DEBUG" = true ] && info "$FUNCNAME" Début "$PROJECT"
  # Verify date pluglist.json
  get_pluglist

  PROJECTS_PATH_PROJECT="$PROJECTS_PATH"/"$PROJECT"
  [ -f "${PROJECTS_PATH_PROJECT}/${PROJECT}.yml" ] || (error "${PROJECTS_PATH_PROJECT}/${PROJECT}.yml non défini"&&exit 1)
  yq . "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml >/dev/null
  [ $? -eq 1 ]&& error Erreur syntaxe fichier configuration du projet&&error Fichier configuration "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml incorrect&&return 1 
 
  MOODLE_VERSION=$(yq .moodle.version   "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.yml
  MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  if [[ "$MOODLE_BRANCH" != null  ]]; then
    [ "$DEBUG" = true ] && echo "Moodle ${MOODLE_MAJOR_VERSION} Branch: $MOODLE_BRANCH" 
  else
    error "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" 
    error=1    
  fi
  
  # validation MOODLE_VERSION
  # MOODLE_VERSION must exists in moodle-version.yml
  # 4.5   latest available relesae in branch
  # 4.5+  Latest available release in branch with fixes
  # 4.5.1 specific release version

  if [[ $MOODLE_VERSION =~ ^4\.[0-5]$ ]]
  then
    [ "$DEBUG" = true ] && echo "Latest available release $MOODLE_VERSION"    
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\+$ ]]
  then
    [ "$DEBUG" = true ] && echo "latest available release with fixes $MOODLE_VERSION"
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]$ ]]
  then
    [ "$DEBUG" = true ] && echo "Specific release in $MOODLE_VERSION"
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]\+$ ]]
  then
    error specific release with fixes in "$MOODLE_VERSION" not yet supoorted...&& error=1
  else
    error Valeur incorecte "$MOODLE_VERSION" && error=1
  fi  
  
  [[ -z "$PROJECT_BRANCH" ]]  && PROJECT_BRANCH="$PROJECT"
  
  [[ -z "$DEPOT_ORIGIN" ]] && DEPOT_ORIGIN=$MOODLE_HQ
    
  [ "$DEBUG" = true ] && echo "Moodle version: $MOODLE_VERSION"
  [ "$DEBUG" = true ] && echo "Moodle version majeure: $MOODLE_MAJOR_VERSION"
  [ "$DEBUG" = true ] && echo "Dépot source Moodle: $DEPOT_ORIGIN"
  [ "$DEBUG" = true ] && echo "Branche projet: $PROJECT_BRANCH"
 
  [ "$DEBUG" = true ] && info "$FUNCNAME" Fin "$PROJECT"
  return $error

}

create_file () {
  error=0
  if [ ! -f "$1" ];then
    touch "$1"
  fi
}

create_dir () {
  error=0
  if [ ! -d "$1" ];then
    mkdir -p "$1"
  fi
}

create_env () {
  
  info "$FUNCNAME" Début
  # Initialisation signal erreur PROJECT_PATH
  error=0

  create_dir "$DEPOT_MODULES"
  create_dir "$PROJECTS_PATH" 
  create_file save.var
  # création projet demo
  
  PROJECT='demo'

  info "$FUNCNAME" Fin
   
}

new_project () {
  
  info "$FUNCNAME" Début
  # Initialisation signal erreur PROJECT_PATH
  error=0
  PROJECT="$1"
  PROJECTS_PATH_PROJECT="$PROJECTS_PATH"/"$PROJECT"
  [[ -d "$PROJECTS_PATH_PROJECT" ]] && echo "Project ${PROJECT} already exist !" && exit 1

  echo Creation environment "$PROJECTS_PATH_PROJECT"
  
  #create_dirsload_
  
  create_dir "$PROJECTS_PATH_PROJECT"
  create_dir "$PROJECTS_PATH_PROJECT"/env 
  create_dir "$PROJECTS_PATH_PROJECT"/releases

  create_file "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  
  echo "# Configuration de ${PROJECT}" >>  "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  echo "# generated by ${USER} ${DATE_DU_JOUR}" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml 
  

  MOODLE_VERSION=$(whiptail --inputbox "What is your Moodle version?" 8 39 --title "Conf $PROJECT" $MOODLE_VERSION 3>&1 1>&2 2>&3)
  echo "moodle:" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  echo "  version: $MOODLE_VERSION" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  
  PROJECT_BRANCH="$PROJECT"
  #echo "PROJECT_BRANCH=$PROJECT" >>  "$PROJECTS_PATH_PROJECT"/"$PROJECT".cnf
  
  cat demo.yml >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  # echo "plugins:" >>"$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  # echo "  moodle-filter_filtercodes:" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  # echo "    source: https://github.com/michael-milette/moodle-filter_filtercodes.git" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  # echo "    branch: master" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  # echo "    plugin_version: v2.6.1" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  #echo "#   localdev:" >> "$PROJECTS_PATH_PROJECT"/plugins.yml
  
    
  create_dir "$PROJECTS_PATH_PROJECT"/env/dev
  create_file "$PROJECTS_PATH_PROJECT"/env/dev/config.php

  echo "all dirs created"
  # shwo for update PROJECT_PATH
  nano "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml
  
  # vérification du fichier de configuration du projet 
  yq . "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml >/dev/null && info Sucessfull || error=1 

  while [ $error -ne 0 ];
  do
    nano "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml
    load_cnf "$PROJECT" && break || continue
  done
  # compatible only with MOODLE_VERSION # X.X+ 
  [[ $MOODLE_VERSION =~ ^4\.[0-5]\+$ ]] || unset MOODLE_DEPTH

  echo "fichier de configuration ${PROJECTS_PATH_PROJECT}/${PROJECT}.yml ok"
  echo "debug PROJECT $PROJECT"
  create_repo_moodle $PROJECT
   
  echo "Project environment ${PROJECT} created"
  info "$FUNCNAME" Fin
}

create_repo_moodle () {

  info "$FUNCNAME" Début
  # Initialisation signal erreur 
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1

  if [ -d $MOODLE_SRC ]; then
    echo $MOODLE_SRC already exists!
    cd $MOODLE_SRC || exit 1

    if [[ ! $(git branch --list | grep "^.*$MOODLE_BRANCH") ]];then
      echo "branch $MOODLE_BRANCH not exists create branch"
      git remote set-branches upstream "$MOODLE_BRANCH"
      [ $? -ne 0 ] && error=1 &&  error git remote set-branches upstream "$MOODLE_BRANCH"&& exit 1
      git fetch upstream "$MOODLE_BRANCH"
      [ $? -ne 0 ] && error=1 &&  error git fetch upsteam "$MOODLE_BRANCH"&& exit 1
      git branch "$MOODLE_BRANCH" upstream/"$MOODLE_BRANCH"
      [ $? -ne 0 ] && error=1 &&  error git branch "$MOODLE_BRANCH" upstream/"$MOODLE_BRANCH"&& exit 1
      # git fetch --tags upstream 
    fi

  else 

    echo $MOODLE_SRC doest noload_t exists
    if [ -z ${MOODLE_DEPTH+x} ]; then
     echo MOODLE_DEPTH is unset
     git clone --branch $MOODLE_BRANCH $DEPOT_ORIGIN  $MOODLE_SRC
    else 
      echo "MOODLE_DEPTH is set to $MOODLE_DEPTH"
      git clone --depth="$MOODLE_DEPTH" --branch "$MOODLE_BRANCH" "$DEPOT_ORIGIN"  "$MOODLE_SRC"
    fi
    [ $? -ne 0 ] && error=1 &&  echo "${red}error git clone $DEPOT_ORIGIN $black"&& exit 1  
    
    cd $MOODLE_SRC || exit 1
    
    if [ $DEPOT_ORIGIN == $MOODLE_HQ ]; then
      echo rename upstream $MOODLE_SRC
      git remote rename origin upstream
      [ $? -ne 0 ] && error=1 &&  error git remote rename origin upstream && exit 1      
    else
      git remote add upstream $MOODLE_HQ
      [ $? -ne 0 ] && error=1 &&  error git remote add origin "$MOODLE_HQ"&& exit 1         
    fi
  fi
  
  set_moodle_current $PROJECT

  # création de la branch projet
  cd $MOODLE_SRC || exit 1
  echo "check creation branch ${PROJECT_BRANCH}"
  if [[ "$(git branch)" != *"${PROJECT_BRANCH}"* ]]; then
    echo "Create Branch ${PROJECT_BRANCH} from ${MOODLE_CURRENT}"
    git branch "${PROJECT_BRANCH}" "${MOODLE_CURRENT}" &&info git branch "$PROJECT_BRANCH" from "$MOODLE_CURRENT" || exit 1  
  fi
  
  git checkout "${PROJECT_BRANCH}" --quiet || (echo "${red} error creation ${PROJECT_BRANCH} ${MOODLE_CURRENT} $black" && exit 1)  
  
  info "$FUNCNAME" Fin

}

set_moodle_current () {
  
  info "$FUNCNAME" Début
  # Initialisation signal erreur 
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  cd $MOODLE_SRC || exit 1

  git checkout $MOODLE_BRANCH --quiet

  # input MOODLE_VERSION
  # output MOODLE_CURRENT

  # MOODLE_VERSION must exists in moodle-version.yml
  # 4.5   latest available release in branch
  # 4.5+  Latest available release in branch with fixes
  # 4.5.1 specific release version

  # echo "Version Moodle majeure: ${MOODLE_VERSION:0:3}"  
  
  # echo MOODLE_BRANCH: "$MOODLE_BRANCH"plugins.yml
  # #echo "MOODLE_VERSION: $MOODLE_VERSION"
  # MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # echo "MOODLE_MAJOR_VERSION: $MOODLE_MAJOR_VERSION"
  # MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  # [[ "$MOODLE_BRANCH" != null ]] && echo "Moodle ${MOODLE_MAJOR_VERSION} Branch: $MOODLE_BRANCH" || echo "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" && exit 1

  
  if [[ $MOODLE_VERSION =~ ^4\.[0-5]$ ]]
  then
    #for example 4.5
    echo "latest available release $MOODLE_VERSION"
    tags=$(git tag -l v"$MOODLE_VERSION"?)
    [ -z $tags ] && error Tags are missing!  && exit 1
    echo $tags    
    MOODLE_CURRENT=v${tags##*v}    
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\+$ ]]
  then
    #for example 4.5+
    echo "latest available release with fixes $MOODLE_VERSION"
    [[ ! $(git checkout $MOODLE_BRANCH --quiet) ]] || error git checkout "$MOODLE_BRANCH"
    MOODLE_CURRENT=$MOODLE_BRANCH
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]$ ]]
  then
    #for example 4.5.1
    echo "specific release $MOODLE_VERSION"
    [[ $(git tag -l "v${MOODLE_VERSION}") ]] || (echo "${red} la release $MOODLE_VERSION n'existe pas $black" && exit 1)   
    MOODLE_CURRENT=v$MOODLE_VERSION
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]\+$ ]]
  then
    echo "specific release with fixes in $MOODLE_VERSION not yet supported" && exit 1    
  else
    echo "Valeur incorecte $MOODLE_VERSION"
  fi  
  
  echo "MOODLE_CURRENT : $MOODLE_CURRENT"
  git checkout "${MOODLE_CURRENT}"  --quiet || (echo "${red}error git checkout ${MOODLE_CURRENT} ${black}" &&exit 1)
  
  info "$FUNCNAME" Fin
}

update_moodle () {

# Initialisation signal erreur 
error=0
#exec 1> >(logger -s -t $(basename $0)) 2>&1
info "$FUNCNAME" Début
PROJECT="$1"
load_cnf $PROJECT || exit 1

set_moodle_current $PROJECT

[ "$DEBUG" = true ] && echo "Parametres:"
[ "$DEBUG" = true ] && echo "  Projet: $PROJECT"
[ "$DEBUG" = true ] && echo "  Version Moodle: $MOODLE_VERSION"
[ "$DEBUG" = true ] && echo "  Branche Moodle: $MOODLE_BRANCH"
[ "$DEBUG" = true ] && echo "  Depot local: $MOODLE_SRC"
[ "$DEBUG" = true ] && echo "  Branche local projet: $PROJECT_BRANCH"
[ "$DEBUG" = true ] && echo "  Moodle courant : $MOODLE_CURRENT"
[ "$DEBUG" = true ] && echo "  Mise à jour depot remote : $MOODLE_UPDATE_ORIGIN" 
# valeur MOODLE_UPDATE_ORIGIN definie dans <nom du PROJECT>.yml

cd "$MOODLE_SRC" || exit 1

echo "Mise à jour $MOODLE_BRANCH depuis upstream"

git fetch upstream "$MOODLE_BRANCH" || (error=1 &&  echo "error git fetch upstream $MOODLE_BRANCH"&& exit 1)
git checkout "$MOODLE_BRANCH" --quiet || (error=1 &&  echo "error git checkout $MOODLE_BRANCH"&& exit 1)
git merge --ff-only  upstream/"$MOODLE_BRANCH" || (error=1 &&  echo "$red error git merge --ff-only  upstream/$MOODLE_BRANCH $black"&& exit 1)

echo "Mise jour $MOODLE_BRANCH depuis upstream effectuée"

# determine Moodle release  
echo "set MOODLE $MOODLE_CURRENT"
git checkout $MOODLE_CURRENT --quiet || (error=1 &&  echo "error git checkout $MOODLE_CURRENT"&& exit 1)

head="$(git rev-parse HEAD)"
echo "commit head $head"

ancestor="$(git merge-base ${PROJECT_BRANCH} HEAD)"
echo "commit ancestor $ancestor"
if [[ $head != $ancestor ]]; then
  # git checkout "${PROJECT_BRANCH}" --quiet
  # git rebase "${MOODLE_CURRENT}"
  # echo "git rebase branch project ${head}"
  git checkout "${PROJECT_BRANCH}" --quiet 
  git merge "${MOODLE_CURRENT}"
  echo "git merge ${MOODLE_CURRENT} branch project ${PROJECT_BRANCH}"
else
  echo "nothing to do already up to date!"
fi

echo "${green}$FUNCNAME Mise à jour OK $black" 
echo

}

add_plugin_cache () {
  
  info "$FUNCNAME" Début
  error=0
  
  parm=$(whiptail --inputbox "New plugin?" 8 39 "" --title "Project" 3>&1 1>&2 2>&3)
  # A trick to swap stdout and stderr.
  # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
  exitstatus=$?

  if [ $exitstatus -ne 0 ]; then    
    error "Select canceled."
    exit 1 
  fi
  # en parametre le plugin recherché sous la forme moodle-<type>_<name>
  # ou abbrégée  <type>_<name
  
  [ -z $parm ] && error "$parm" Parametre plugin missing && exit
  [[ "$parm" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}" || component_name="$parm"
  PLUGIN='moodle-'"$component_name"
  [ "$DEBUG" = true ] && info Import: "$PLUGIN"
  if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then
    info $PLUGIN already exists
    exit
  fi 

  if [[ "$PLUGIN" =~ ^moodle-([a-z]*)_(.*)$ ]]; then
    type="${BASH_REMATCH[1]}"
    [ "$DEBUG" = true ] && info type: "$type"
    name="${BASH_REMATCH[2]}"
    [ "$DEBUG" = true ] && info name: "$name"
    dir=$(jq -r .plugintypes.${type} "$SCRIPT_DIR"/types.json)
    if [ $dir == null ]; then
      error type: "$type" invalide
      exit    
    fi   
  else
    error "syntax error must be [moodle-]<type>_<name>"
    exit
  fi
  
  # Recherche dans le fichier de référence
  
  jq -r --arg plugin  "$component_name" '.plugins| map(select(.component == $plugin)) | .[]' "$SCRIPT_DIR"/pluglist.json > my.json
  var=$(jq '.id' my.json)
  [ ! $var == '' ] && info "$component_name" found "$var" || error nothing found
 
#jq -r '.name' myplugin.json
#jq -r '{ component: .component , name: .name, source: .source }' myplugin.json
  NAME=$(jq -r '.name' my.json)
  SOURCE=$(jq -r '.source' my.json)  
  [[ $SOURCE  =~ ^.*\/\/.*\/.*\/(.*)$ ]] && echo "${BASH_REMATCH[1]}"
  
  #jq -r --arg fullname "$full_name" '{name: .name,source: .source}'  my.json
  
  # Add plugin 
  info Source: "$SOURCE"
  if [[ ! $SOURCE ]]; then 
    info "$PLUGIN" non trouvé
    SOURCE=$(whiptail --inputbox "Source du plugin?" 8 39 "https://github.com//$PLUGIN" --title "Project" 3>&1 1>&2 2>&3)
  # A trick to swap stdout and stderr.
  # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
    exitstatus=$?

    if [ $exitstatus -ne 0 ]; then    
      error "Select canceled."
      exit 1 
    fi    
    info Source du plugin "$PLUGIN":"$SOURCE"
  fi

  cd "$DEPOT_MODULES" || exit
  git clone "$SOURCE" $PLUGIN
  [ $? -ne 0 ] && error erreur git clone "$SOURCE" "$PLUGIN" && exit 9
  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
  git remote rename origin upstream
  [ $? -ne 0 ] && error erreur git remote rename origin  upstream && exit 12
  LAST_PLUGIN="$PLUGIN"
  [ "$DEBUG" = true ] && info Last_plugin: "$LAST_PLUGIN"
  info "$FUNCNAME" Fin
}

add_plugin_project () {

  info "$FUNCNAME" Début
  
  PLUGIN=$(whiptail --inputbox "New plugin?" 8 39 "$LAST_PLUGIN" --title "Project" 3>&1 1>&2 2>&3)
  # A trick to swap stdout and stderr.
  # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
  exitstatus=$?

  if [ $exitstatus -eq 0 ]; then  
    if [[ projects/"$PROJECT" =~ ^.*"$PLUGIN".*$ ]]; then
      error "$PLUGIN" already in plugins list
      error=1
    else
      if [[ -d "$DEPOT_MODULES"/"$PLUGIN" ]]; then
         cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
        [[ "$PLUGIN" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}"
        jq -r --arg plugin  "$component_name" '.plugins| map(select(.component == $plugin)) | .[]' "$SCRIPT_DIR"/pluglist.json > my.json
        var=$(jq '.id' my.json)
        [ ! $var == '' ] && info "$var" || error nothing found
        NAME=$(jq -r '.name' my.json)
        SOURCE=$(jq -r '.source' my.json)  
        [[ $SOURCE  =~ ^.*\/\/.*\/.*\/(.*)$ ]] && echo "${BASH_REMATCH[1]}"
        if [[ ! "$SOURCE" ]]; then           
           url=$(cat .git/config | grep -E "^.*url.*$")
           [ "$DEBUG" = true ] && info url: "$url"
           [[ "$url"  =~ ^.*(https:.*)$ ]] && SOURCE="${BASH_REMATCH[1]}"
        fi
        echo "" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        echo "  $PLUGIN:" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        echo "    name: $NAME" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        echo "    source: $SOURCE" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        select_plugin_branch "$PLUGIN"
        echo "    branch: $PLUGIN_BRANCH" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      else
        error "$PLUGIN" not already imported
        error=1
      fi
    fi
  else
      error "Select canceled."
      error=1 
  fi
  
  info "$FUNCNAME" Fin
}

select_plugin_branch () {
  info "$FUNCNAME" Début

  PLUGIN="$1"
  PLUGIN_BRANCH=''
  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1

  [ "$DEBUG" = true ] && info Branche Moodle: "$MOODLE_BRANCH"
  info "Plugin: $PLUGIN"

  local found
  found=false
  if [[ $(git branch -r | grep -E "^  upstream\/$MOODLE_BRANCH$") ]]; then
      PLUGIN_BRANCH="$MOODLE_BRANCH"
      info "Bingo Moodle branch $MOODLE_BRANCH match !"
      found=true
  else 
      branch_stable_remote=$(git branch -r | grep -E "^  upstream\/MOODLE_[0-9]{3}_STABLE$" | sort -rn | head -n 1)
      info "default best highest remote branch $branch_stable_remote"
      if [[ "$branch_stable_remote" ]]; then        
        if [[ $branch_stable_remote =~ ^.*upstream\/(.*)$ ]]; then
          PLUGIN_BRANCH="${BASH_REMATCH[1]}"
          found=true
        fi
      fi 
  fi
  
  if [ $found = false ]; then  
    if [[ $(git rev-parse --verify upstream/master 2>/dev/null) ]]; then      
      PLUGIN_BRANCH=master
      found=true
      info Branch remote master exists
    elif [[ $(git rev-parse --verify upstream/main 2>/dev/null) ]]; then      
      PLUGIN_BRANCH=main
      found=true
      info Branch remote main selectionnée
    fi
  fi
  
  if [ $found = true ]; then
    if [[ $(git rev-parse --verify "$PLUGIN_BRANCH" 2>/dev/null) ]]; then
     info "$PLUGIN_BRANCH selected exists"
    else 
      git branch "$PLUGIN_BRANCH" remotes/upstream/"$PLUGIN_BRANCH"
      info "$PLUGIN_BRANCH" créée
    fi
  fi 
  [[ "$PLUGIN_BRANCH" != null ]]&& git checkout "$PLUGIN_BRANCH" --quiet
  info "$FUNCNAME" Fin
}

edit_plugins () { 
  
  info "$FUNCNAME" Début
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  PROJECTS_PATH_PROJECT="$RACINE"/projects/"$PROJECT"
  local date_before date_after 
  date_before=$(date -r "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  pluginsbefore=$(yq '.plugins | keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo "Nb plugins avant maj : ${#pluginsbefore[@]}"

  nano "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml

  date_after=$(date -r "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  if [ "$date_after" != "$date_before" ]; then
     [ "$DEBUG" = true ] && echo "il y a eu des maj..."
    # check validity .yml 
    yq "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml >/dev/null || exit 1
    pluginsafter=$(yq '.plugins | keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
    [ "$DEBUG" = true ] && echo "Nb plugins apres maj : ${#pluginsafter[@]}"
    # on ne récupere que les plugins uniques donc uniquement ceux supprimés et non aussi ceux ajoutés !
    plugins_suppress=($(echo ${pluginsbefore[@]} ${pluginsafter[@]} ${pluginsafter[@]} | tr ' ' '\n' | sort | uniq -u))
    [ "$DEBUG" = true ] && echo "nb plugins à supprimmer: ${#plugins_suppress[@]}"
    for key in "${!plugins_suppress[@]}"; do
      echo "a supprimmer: $key ${plugins_suppress[$key]}"
      suppress_plugin "$PROJECT" "${plugins_suppress[$key]}"
    done
    update_codebase "$PROJECT"
  else
    echo "Pas de modification de la liste des plugins"
  fi  

  info "$FUNCNAME" Fin

}
  # PLUGINS="$PROJECTS_PATH_PROJECT"/plugins.yml
  # date_last_modif=$(date -r "$PLUGINS")

  # readarray pluginsbefore < <(yq 'to_entries | .[] | .key' "$PLUGINS")
  # #ARLENGTH=${#pluginsbefore[@]}
  # [ "$DEBUG" = true ] && echo "Nb plugins avant maj : ${#pluginsbefore[@]}"
 
  # nano "$PROJECTS_PATH_PROJECT"/plugins.yml
  # date_last=$(date -r "$PLUGINS")
  # if [ "$date_last_modif" != "$date_last" ]; then
  #   # check validity .yml 
  #   yq "$PROJECTS_PATH_PROJECT"/plugins.yml || (error structure de plugins.yml incorrecte && exit 1)
  #   # check suppress plugin 
  #   readarray pluginsafter < <(yq 'to_entries | .[] | .key' $PLUGINS)
  #   [ "$DEBUG" = true ] && echo "Nb plugins apres maj : ${#pluginsafter[@]}"
  #   # on ne récupere que les plugins unique donc uniquement ceux supprimés et non aussi ceux ajoutés !
  #   plugins_suppress=($(echo ${pluginsbefore[@]} ${pluginsafter[@]} ${pluginsafter[@]} | tr ' ' '\n' | sort | uniq -u))
  #   echo "nb plugins à supprimmer: ${#plugins_suppress[@]}"
  #   for key in "${!plugins_suppress[@]}"; do
  #     echo "a supprimmer: $key ${plugins_suppress[$key]}"
  #     suppress_plugin "${plugins_suppress[$key]}"
  #   done
        
  #   update_codebase
  # else
  #   echo "Pas de modification de la liste des plugins"
  # fi


update_repo () {  
  
  info "$FUNCNAME" Début   
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1 
  PLUGINS=$(yq '.plugins | keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do    
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    echo "  check plugin: $PLUGIN"
    if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then	   
      upgrade_plugin "$PROJECT" "$PLUGIN"
    else
      import_plugin "$PROJECT" "$PLUGIN"
    fi
  done

  info "$FUNCNAME" Fin 

}

upgrade_plugin () {
  
  info "$FUNCNAME" Début
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
  cd $DEPOT_MODULES/$PLUGIN || exit 1
  echo $PLUGIN already exists check if new version exists 
  
  set_plugin "$PROJECT" "$PLUGIN"
  
  git checkout --quiet $BRANCH_PLUGIN ||(echo "$red La branche $BRANCH_PLUGIN n'existe pas $black" && exit 1)

  if [[ $PLUGIN_VERSION == null ]]; then    

    # SITEREMOTE=$(git remote | grep 'upstream')
    # [ $SITEREMOTE != 'upstream' ] && error=1 && echo "$red site remote upstream missing $black" && exit 1
    
    git fetch --quiet upstream || (error=1 &&  echo "$red error git fetch upstream $black")
    git show-ref --verify --quiet refs/heads/"$BRANCH_UPSTREAM" || (error=1 &&  echo "$red error  git show-ref ref/heads/$BRANCH $black")   
     
    BRANCHREMOTE=$(git rev-parse --abbrev-ref $BRANCH_UPSTREAM@{upstream})
    [ "$DEBUG" = true ]&&echo "branche remote : $BRANCHREMOTE" 
     
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse @{u})
    BASE=$(git merge-base @ @{u})
    
    [ "$DEBUG" = true ]&&echo LOCAL:  "$LOCAL"
    [ "$DEBUG" = true ]&&echo REMOTE: "$REMOTE"
    [ "$DEBUG" = true ]&&echo BASE:   "$BASE"

    if [ "$LOCAL" = "$REMOTE" ]; then
      echo "$green$PLUGIN branche $BRANCH up-to-date with remote $BRANCHREMOTE $black"
    elif [ "$LOCAL" = "$BASE" ]; then           
      echo $yellow $BRANCH_UPSTREAM need to pull from remote $BRANCHREMOTE $black 
      # git fetch --quiet upstream
      # [ $? -ne 0 ] && error=1 &&  echo "$red error git fetch --quiet upstream $black" && exit 1
      if [ "$PLUGIN_UPGRADE_AUTO" == true ];then        
        echo "Mise à jour automatique du plugin $PLUGIN"
        git fetch --quiet upstream || (echo "$red error git checkout --quiet upstream $black" && exit 1)
        git checkout --quiet $BRANCH_UPSTREAM || (error=1 &&  echo "$red error git checkout --quiet $BRANCH_UPSTREAM $black" && exit 1)
        git merge --quiet --ff-only upstream/$BRANCH_UPSTREAM || (error=1 &&  echo "$red error git merge --quiet --ff-only upstream/$BRANCH_UPSTREAM $black" && exit 1)
         
        if [ $LOCALDEV != null ]; then 
          EXISTS=$(git show-ref refs/heads/"$LOCALDEV")
          if [[ -z $EXISTS ]]; then
            git branch --quiet $LOCALDEV $BRANCH_UPSTREAM || (error=1 &&  echo $red error git branch --quiet $LOCALDEV $BRANCH_UPSTREAM $black && exit 1)
          fi
          git checkout --quiet "$LOCALDEV" || (error=1 &&  echo $red error git checkout $LOCALDEV $black && exit 1)
          git rebase --quiet "$BRANCH_UPSTREAM"
          if [ $? -eq 0 ]; then
            echo $green $LOCALDEV git rebase "$BRANCH_UPSTREAM" successfull $black
          else 
            echo "$red error $LOCALDEV git rebase $BRANCH_UPSTREAM $black" && exit 1
          fi
        fi
      fi
    elif [ "$REMOTE" == "$BASE" ]; then           
        echo "$yellow $BRANCH_UPSTREAM need to push to remote $BRANCHREMOTE $black"
    else           
        echo "$red $BRANCH_UPSTREAM diverged with remote $BRANCHREMOTE !!! $black" && exit 1
    fi
  else
    # cas pinned version     
    # check contains 

    if [[ 0 -eq $(git merge-base --is-ancestor "$PLUGIN_VERSION" HEAD) ]]; then
      echo "$green $PLUGIN / $BRANCH_PLUGIN contains pinned version $PLUGIN_VERSION $black"
     else
      error=1
      echo "$red $BRANCH_PLUGIN does not contains pinned version $PLUGIN_VERSION $black"
      exit
    fi

    git reset --hard "$PLUGIN_VERSION"
    [ $? -ne 0 ] && error=1 &&  echo "$red git reset --hard $PLUGIN_VERSION $black" && exit 1
  fi

  info "$FUNCNAME" Fin
}

import_plugin () {

  info "$FUNCNAME" Début 
  echo "$PLUGIN new import into local repository"
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  PLUGIN="$2"
  [ "$DEBUG" = true ]&&echo "debug $FUNCNAME $PROJECT $PLUGIN"
  set_plugin "$PROJECT" "$PLUGIN" 
  cd "$DEPOT_MODULES" || exit 1  
  git clone  "$SOURCE" "$PLUGIN" --quiet
  [ $? -ne 0 ] && error erreur git clone "$SOURCE" "$PLUGIN" && exit 9
  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
  git remote rename origin upstream
  [ $? -ne 0 ] && error erreur git remote rename origin  upstream && exit 12
  
  
  git checkout "$BRANCH_UPSTREAM" --quiet
  if [[ $? -ne 0 ]]; then
    echo creation branche "$BRANCH_UPSTREAM"
    git branch '$BRANCH_UPSTREAM" remotes/upstream/"$BRANCH_UPSTREAM' --quiet
    [ $? -ne 0 ] && echo "$red erreur git branch --quiet remotes/upstream/$BRANCH_UPSTREAM $black" && exit 13
    git checkout "$BRANCH_UPSTREAM" --quiet
    [ $? -ne 0 ] && echo "$red erreur git checkout --quiet $BRANCH_UPSTREAM $black" && exit 14
  fi
  
  if [[ "$PLUGIN_VERSION" != null ]]; then
    [ "$DEBUG" = true ]&&echo PLUGIN_VERSION: "$PLUGIN_VERSION"
    git checkout "$PLUGIN_VERSION" --quiet || (echo "${red} $PLUGIN_VERSION n'est pas un tag ou 1 commit du plugin $PLUGIN $black" && exit 1)
    BRANCH_PLUGIN="$PLUGIN_VERSION"
  elif [[ "$LOCALDEV" != null ]]; then
    if [[ "$(git branch)" != *"${LOCALDEV}"* ]]; then
      echo "Create Branch ${LOCALDEV} from ${BRANCH_UPSTREAM}"
      git branch "${LOCALDEV}" "${BRANCH_UPSTREAM}" || (echo "${red} error git branch ${LOCALDEV} ${BRANCH_UPSTREAM} $black" && exit 1)  
      echo "branch localdev $LOCALDEV created "
    fi
    BRANCH_PLUGIN="$LOCALDEV"
  else
     BRANCH_PLUGIN="$BRANCH_UPSTREAM"  
  fi
  # verification avnat de quitter

  git checkout $BRANCH_PLUGIN --quiet || (echo "${red} error git checkout ${BRANCH_PLUGIN} $black" && exit 1) 
  
  # if [[ $LOCALDEV != null ]]; then
  #   git branch "$LOCALDEV" "$BRANCH_UPSTREAM"  --quiet
  #   [ $? -ne 0 ] && echo "$red erreur git checkout --quiet $BRANCH_UPSTREAM $black" && exit 1
  #   echo "$green branch localdev $LOCALDEV created $black" && exit 1
  # fi
  
  # if [[ $PLUGIN_VERSION != null ]]; then
  #     set_version
  # fi 
  
  [ "$DEBUG" = true ]&& echo "$PLUGIN" type: "$TYPE" dir: "$DIR"
  echo "$green $UNAME est cloné sous le nom $PLUGIN dans le depot local $DEPOT_MODULES $black"
  
  info "$FUNCNAME" Fin
}

set_plugin () {  

  [ "$DEBUG" == true ] && info "$FUNCNAME" Début "$PLUGIN"
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"

  # OWNER=$(yq .plugins."$PLUGIN".owner "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  # REPO=$(yq .plugins."$PLUGIN".repo "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)   
  
  # if [ "$REPO" == 'github' ]; then 
  #   UPSTREAM=https://github.com/$OWNER 
  # elif [ "$REPO" = 'bitbucket' ]; then  
  #   if [ "$OWNER" == 'cbillon' ]; then
  #     UPSTREAM=git@bitbucket.org:$OWNER 
  #   else 
  #     UPSTREAM=https://$OWNER@bitbucket.org/$OWNER 
  #   fi    
  # else
  #   error Type depot inconnu "$REPO" only supported github bitbucket && exit     
  # fi   
  SOURCE=$(yq .plugins."$PLUGIN".source "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)  
  BRANCH_UPSTREAM=$(yq .plugins."$PLUGIN".branch "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)  
  PLUGIN_VERSION=$(yq .plugins."$PLUGIN".version "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  LOCALDEV=$(yq .plugins."$PLUGIN".localdev "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  #if LOCALDEV not defined set to null
  if [[ "$PLUGIN_VERSION" != null ]]; then    
    BRANCH_PLUGIN="$PLUGIN_VERSION"
    [ "$DEBUG" = true ] && echo "BRANCH_PLUGIN: $BRANCH_PLUGIN  from PLUGIN_VERSION not null: $PLUGIN_VERSION"
  elif [[ "$LOCALDEV" != 'null' ]]; then
    BRANCH_PLUGIN="$LOCALDEV"
    [ "$DEBUG" = true ] && echo "BRANCH_PLUGIN: $BRANCH_PLUGIN from LOCALDEV not null: $LOCALDEV"
  else
    BRANCH_PLUGIN="$BRANCH_UPSTREAM"  
    [ "$DEBUG" = true ] && echo "BRANCH_PLUGIN: $BRANCH_PLUGIN from default plugin's branch: $BRANCH_UPSTREAM"
  fi  
  
 # ORIGINAL_NAME=$(yq .plugins."$PLUGIN".originalname "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
 #if ORIGINAL_NAME not defined set to null
 # if [[ "$ORIGINAL_NAME" == null ]]; then
 #    UNAME="$PLUGIN" 
 # else
 #    UNAME="$ORIGINAL_NAME"    
 # fi
   
  # DIR inclusion

  ss=${PLUGIN#*-}
  NOM=${PLUGIN#*_}
  TYPE=${ss%%_*}

# le fichier components.json permet de determiner le reprtoire de destination a partir du nom du plugin
# pour convertir au format yaml : yq -oy components.json > components.yml

  #DIR=$(jq .plugintypes.$TYPE $RACINE/components.json | tr -d '"') 
  
  DIR=$(yq ".plugintypes.$TYPE" "$RACINE"/components.yml)
  if [[ $DIR == 'null' ]];
    then error=1 && echo "$red Attention prefixe $TYPE  inconnu $black" exit 1    
  fi

  [ "$DEBUG" = true ] && echo "  PLUGIN: $PLUGIN" 
 # [ "$DEBUG" = true ] && echo "  OWNER: $OWNER"
 # [ "$DEBUG" = true ] && echo "  REPO: $REPO"
  [ "$DEBUG" = true ] && echo "  UPSTREAM: $UPSTREAM"
  [ "$DEBUG" = true ] && echo "  BRANCH_UPSTREAM: $BRANCH_UPSTREAM"
  [ "$DEBUG" = true ] && echo "  LOCALDEV: $LOCALDEV"  
  [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN"
  [ "$DEBUG" = true ] && echo "  SOURCE: $SOURCE"
  [ "$DEBUG" = true ] && echo "  PLUGIN VERSION : $PLUGIN_VERSION"
  [ "$DEBUG" = true ] && echo "  DIR : $DIR"

  [ "$DEBUG" = true ] && info "$FUNCNAME" Fin
} 

update_codebase () {

  info "$FUNCNAME" Début
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  # Etape 1 met à jour le depot local de plugin
  update_repo "$PROJECT"
  # Etape 2 met à jour la base de code
  echo "check for each plugin if correct version is installed in codebase"
  
  cd "${MOODLE_SRC}" || exit 1
  echo "PROJECT BRANCH: ${PROJECT_BRANCH}"
  git checkout "${PROJECT_BRANCH}" --quiet || (echo "${red}error ${black}" && exit 1)

  PLUGINS=$(yq '.plugins | keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do
    echo "  check plugin: $PLUGIN"
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    echo "check: $PLUGIN"
    set_plugin "$PROJECT" "$PLUGIN"    
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1

  # BRANCH_UPSTREAM branche du plugin dans le depot source
  # BRANCH_PLUGIN branche à utiliser 
  # = BRANCH_UPSTREAM quand il n'y a pas de de local
  # = LOCALDEV  branch de dev local  
  # = PLUGIN_VERSION quand il existe une version explicite du plugin la branche BRANCH_PLUGIN  est crée à ce commit lors de création ou de la mise à jour
    echo "branch plugin $BRANCH_PLUGIN"
    git checkout "$BRANCH_PLUGIN" --quiet
    [ $? -ne 0 ] && error=1 &&  echo "$red error git checkout plugin $PlUGIN_VERSION $black"&& exit 1
  
    LOCAL=$(git rev-parse @)

    if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then
    # module already installed
      cd "$MOODLE_SRC"/"$DIR"/"$NOM" || exit 1     
      #for sha1 complet -c11-50 
      COMMIT=$(grep .gitrepo -e 'commit = ' | cut -c11-50) 
      [ "$DEBUG" = true ]&& echo "Branche $BRANCH_PLUGIN commit: $COMMIT local: $LOCAL"    

      if [[ "$COMMIT" == "$LOCAL" ]]; then    
        # MOD='OK'
        echo "$green $PLUGIN est installe dans $MOODLE_SRC/$DIR/$NOM et est à jour OK $black"
      else     
        # MOD='UPD'
        echo $yellow $PLUGIN est installe dans $MOODLE_SRC/$DIR/$NOM mais n est pas à jour UPD $black  
        #echo git subtree pull --prefix=${dir}/${NOM} --squash  $DEPOT_MODULES/$2 ${BRANCHE}
        #echo git subrepo pull ${MOODLE_SRC}/${dir}/${NOM} -b ${BRANCH} 
        cd  $MOODLE_SRC || exit 1 
        git subrepo pull "$DIR"/"$NOM" -b "$BRANCH_PLUGIN" --message "Update $PLUGIN $BRANCH"
        [ $? -ne 0 ] && error=1 &&  echo error git subrepo pull $DIR/${NOM} -b ${BRANCH} 
        echo "$green $PLUGIN mis à jour dans le répertoire $DIR $black"  
      fi
    else      
      # MOD='ADD' 
      echo "$yellow $PLUGIN n'est pas installé dans $MOODLE_SRC/$DIR/$NOM. Mode mise à jour ADD $black"
      echo "$PLUGIN type: $TYPE path: $DIR branch: $BRANCH_PLUGIN"
      #echo git subtree add --prefix=${dir}/${NOM} --squash  $DEPOT_MODULES/$2 ${BRANCH}  
      cd  $MOODLE_SRC || exit 1 
      [ "$DEBUG" = true ]&&echo  git subrepo clone $DEPOT_MODULES/$PLUGIN $DIR/$NOM -b $BRANCH_PLUGIN
      git subrepo clone --message "Add $PLUGIN $BRANCH_PLUGIN" "$DEPOT_MODULES"/"$PLUGIN" "$DIR"/"$NOM" -b "$BRANCH_PLUGIN"
      [ $? -ne 0 ] && error=1 &&  echo "$red" error "$DEPOT_MODULES"/"$PLUGIN" "$DIR"/"$NOM" -b "$BRANCH_PLUGIN" "$black" && exit 1  
      echo "$green $PLUGIN / $BRANCH_PLUGIN ajouté dans le répertoire $DIR $black" 
    fi
  
  done

 info "$FUNCNAME" Fin

}

release () {

info "$FUNCNAME" Début
echo "Projet $PROJECT Branche source Moodle: $PROJECT_BRANCH"
error=0
PROJECT="$1"
load_cnf "$PROJECT" || exit 1
# $2 MSG for new release
[  -z "$2" ] && MSG='cb' || MSG="$2"
NEWRELEASE=$(date +%Y.%m.%d@%Hh%M)
  
cd "$MOODLE_SRC" || exit 1
git checkout $PROJECT_BRANCH --quiet 
[ $? -ne 0 ]&& error "Erreur git checkout $PROJECT_BRANCH"&& exit 1
  
git commit --allow-empty -m $MSG
[ $? -ne 0 ]&& error "Erreur git commit --allow-empty "&& exit 1

git tag -a "$NEWRELEASE" -m ""
[ $? -ne 0 ]&& error "Erreur git tag $NEWRELEASE $black"&& exit 1

info Start build "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"
mkdir -p  "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE" || exit 1
cp -r $MOODLE_SRC/*   "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"/
rm -rf "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"/.git
info End build "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"

#
[ -L "$PROJECTS_PATH_PROJECT"/releases/current ] && unlink "$PROJECTS_PATH_PROJECT"/releases/current
  
# ln -s ${RELEASES}/$NEWRELEASE current_temp
# mv -Tf current_temp  ${PROJECTS_PATH_PROJECT}/current

ln -s "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE" "$PROJECTS_PATH_PROJECT"/releases/current

echo New current relesae: $(readlink "$PROJECTS_PATH_PROJECT"/releases/current) 

# create <PROJECT>.lock
project_lock "$PROJECT"

if [[ "$MOODLE_UPDATE_ORIGIN" == 'Y' ]]; then
  echo "Mise à jour $PROJECT_BRANCH dans repository origin"
  git push origin "$PROJECT_BRANCH"
  [ $? -ne 0 ] && error=1 &&  echo "error git push $PROJECT_BRANCH"&& exit 1
fi

info "$FUNCNAME" Fin
}

function project_lock () {
 
  PROJECT="$1"
  info "$FUNCNAME" Début "$PROJECT"
  error=0
  load_cnf "$PROJECT"  && echo conf $PROJECT successfully loaded || exit
  cd "$PROJECTS_PATH"/"$PROJECT" || exit 1
  # create "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  [ -f "$PROJECT".lock ] && rm "$PROJECT".lock 
  cp "$PROJECT".yml "$PROJECT".lock

  cd "$MOODLE_SRC" || exit 1
  git checkout "$PROJECT" --quiet
  [ "$DEBUG" = true ] && echo $(git rev-parse --abbrev-ref HEAD) $(git rev-parse --short HEAD)
  moodlesha1=$(git rev-parse --short HEAD) yq -i '.moodle.version=strenv(moodlesha1)' $PROJECTS_PATH/$PROJECT/$PROJECT.lock 
  moodlebranch=$(git rev-parse --abbrev-ref HEAD) yq -i '.moodle.branch=strenv(moodlebranch)' $PROJECTS_PATH/$PROJECT/$PROJECT.lock 

  PLUGINS=$(yq '.plugins | keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do     
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    [ "$DEBUG" = true ] &&echo "  check plugin: $PLUGIN"
    set_plugin "$PROJECT" "$PLUGIN"
    [[ $(cat "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo | grep 'commit') =~ .*=.([0-9a-z]+) ]] && commit="${BASH_REMATCH[1]}" 
    pathenv=".plugins.$PLUGIN" commit=${commit:0:7} yq -i 'eval(strenv(pathenv)).version = strenv(commit)' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  done
  info "$FUNCNAME" Fin "$PROJECT"
  return $error
}

function saved_releases () {

  info "$FUNCNAME" Début
  PROJECT="$1"
  cd "$PROJECTS_PATH"/"$PROJECT"/releases
  local nb_releases release
  nb_releases=$(ls -l | wc -l)
  info Nb releases: $nb_releases
  while [ $nb_releases -gt $MAX_RELEASES ]; do
    release=$(ls -tr | head -n 1) 
    rm -r $release && info "$nb_releases delete $release"
    nb_releases=$(ls -l | wc -l)
  done

  info "$FUNCNAME" Fin

}


deploy () {

  info "$FUNCNAME" Début
  PROJECT="$1"
  load_cnf "$PROJECT"
  [  -z "$2" ] && RELEASE='current' || RELEASE="$2"
  info Release: "$RELEASE"
  
  DEPLOYMENT_ENV=$(whiptail --inputbox "What is your deployment environnement ?" 8 39 "$DEPLOYMENT_ENV" --title "Project" 3>&1 1>&2 2>&3)
  
  exitstatus=$?

  if [ $exitstatus = 0 ]; then    
    if [ -d "$PROJECTS_PATH"/"$PROJECT"/env/"$DEPLOYMENT_ENV" ]; then    
    info "Deploiement environment: $DEPLOYMENT_ENV"
    cd "$PROJECTS_PATH"/"$PROJECT"/env/"$DEPLOYMENT_ENV" || exit 1    
    sudo rsync -a "$PROJECTS_PATH"/"$PROJECT"/releases/current/* ~/moodle/docker_moodle_minimal/moodle/
    sudo cp config.php ~/moodle/docker_moodle_minimal/moodle/
    docker exec -it docker_moodle-app  php admin/cli/upgrade.php
    saved_releases "$PROJECT"
    info "That's ALL!"
  else
    echo "Deploiement environment: $DEPLOYMENT_ENV"
    if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Create new environment $DEPLOYMENT_ENV ?" 10 60); then      
      info new_env "$DEPLOYMENT_ENV" && info env "$DEPLOYMENT_ENV" created  || error Error in "$DEPLOYMENT_ENV"
    else
       echo "Cancel."
       exit 1 
    fi 
  fi
else 
   echo "Select new canceled."
   exit 1 
fi


#  [ -d "$PROJECTS_PATH_PROJECT"/config-php ] || mkdir "$PROJECTS_PATH_PROJECT"/config-php
  

# Mise à jour de config.php
#  si existe on prend ${PROJECTS_PATH_PROJECT}/config-php/config.php" 
#  Sinon on le récupère ${PROJECTS_PATH_PROJECT}/current/config.php 
# sinon rien (sera cree lors de l'installation)

# if [ -e "$PROJECTS_PATH_PROJECT"/config-php/config.php ]; then  
#   echo "Recopie config.php depuis $PROJECTS_PATH_PROJECT/config-php/config.php"   
#   cp "$PROJECTS_PATH_PROJECT"/config-php/config.php "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"/
# elif [ -e "$PROJECTS_PATH_PROJECT"/current/config.php ];  then
#   echo "Recopie config.php depuis derniere release $PROJECTS_PATH_PROJECT/current/config.php si elle existe"
#   cp $PROJECTS_PATH_PROJECT/current/config.php "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"
#   #et aussi  sauvegarde 
#   cp $PROJECTS_PATH_PROJECT/current/config.php $PROJECTS_PATH_PROJECT/config-php/
# fi

  info "$FUNCNAME" Fin

}
versionrestore () {
  error=0
  CURRENTVERSION=$(readlink ${PROJECTS_PATH_PROJECT}/current)
  [ "$DEBUG" = true ] && echo Version courente: $CURRENTVERSION 
  cd $RELEASES || exit 1  
  files=(*)
  ARLENGTH=${#files[@]}
  [ "$DEBUG" = true ] && echo "Nb version: $ARLENGTH"
  [[ "${ARLENGTH}" < 2 ]] && echo "il ne reste qu'une version !" && exit 1
  LIST=()
  for ((i=0; i<$ARLENGTH; i++))
    do
      if [[ $RELEASES/${files[$i]} == $CURRENTVERSION ]]; then
        # echo version courante $i 
        # LIST+=(${i}  *${files[$i]}) 
        continue
      else
        echo version autre    $i
        LIST+=($i ${files[$i]})
      fi
  done 

 
  VER=$(whiptail --title "Restoration d'une version" --menu "$CURRENT" 20 100 "${ARLENGTH}" "${LIST[@]}" 3>&1 1>&2 2>&3)
  exitstatus=$?
 
  if [ $exitstatus = 0 ]; then    
    
    NEWCURRENT="${files[${VER}]}"
    echo "Version sélectionnée: $NEWCURRENT"        
    if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Version sélectionnée: $NEWCURRENT" 10 60) then  
      echo VER: $VER
      [ -L "${PROJECTS_PATH_PROJECT}/current" ] && unlink "${PROJECTS_PATH_PROJECT}/current" && echo Suppression du lien current
      ln -s $RELEASES/$NEWCURRENT $PROJECTS_PATH_PROJECT/current
      echo New current: $(readlink "${PROJECTS_PATH_PROJECT}/current") 
    else
        echo "Abandon du traitement"
    fi    
    sortie=0 
  else
      echo "Abandon du traitement"
  fi

}
 
versionsuppress () {
  error=0
  CURRENTVERSION=$(readlink $PROJECTS_PATH_PROJECT/current)
  [ "$DEBUG" = true ] && echo "Version courente: $CURRENTVERSION"
  cd "$RELEASES" || exit 1  
  files=(*)
  ARLENGTH=${#files[@]}
  [ "$DEBUG" = true ] && echo "Nb version: $ARLENGTH"
  [[ "$ARLENGTH" -lt 2 ]] && echo "il ne reste qu'une version !" && exit 1

  LIST=()
  for ((i=0; i < $ARLENGTH; i++))
    do
      if [[ "${RELEASES}"/${files[$i]} == $CURRENTVERSION ]];
      then
        # echo version courante $i "${RELEASES}"/${files[$i]}
        # LIST+=(${i}  *${files[$i]}) 
        continue
      else
        [ "$DEBUG" = true ] && echo version autre    $i "$RELEASES"/${files[$i]}
        LIST+=($i ${files[$i]})
      fi
  done  
 
  VER=$(whiptail --title "Suppression d'une version" --menu "$CURRENT" 20 100 "$ARLENGTH" "$LIST[@]" 3>&1 1>&2 2>&3)
  exitstatus=$?
 
  if [ $exitstatus = 0 ]; then    
    
    SUPPRESS="${files[${VER}]}"
    echo "Version sélectionnée: $SUPPRESS"    
    if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Version sélectionnée: $SUPPRESS" 10 60) then  
      echo Version supprimée: "$SUPPRESS"
      sudo rm -rf "$SUPPRESS"
    else
        echo "Abandon du traitement"
    fi    
    sortie=0 
  else
      echo "Abandon du traitement"
  fi
  
}
suppress_plugin () {

  info "$FUNCNAME" Début
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  PLUGIN=$2

  echo " Suppression du plugin ${PLUGIN}" 
        
  if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Suppression du plugin ${PLUGIN}" 10 60) 
  then

    # DIR inclusion

    ss=${PLUGIN#*-}
    NOM=${PLUGIN#*_}
    TYPE=${ss%%_*}

    # le fichier components.json permet de determiner le reprtoire de destination a partir du nom du plugin
    # pour convertir au format yaml : yq -oy components.json > components.yml
    #DIR=$(jq .plugintypes.$TYPE $RACINE/components.json | tr -d '"') 
  
    DIR=$(yq ".plugintypes.$TYPE" "$RACINE"/components.yml)
    if [[ $DIR == 'null' ]];
      then error=1 && echo "$red Attention prefixe $TYPE inconnu $black" exit 1    
    fi

    if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; 
    then
      cd "$MOODLE_SRC" || exit 1
      git subrepo clean "$dir"/"$nom"
      [ $? -ne 0 ] && error=1 &&  echo "$red error git subrepo clean ${DIR}/${NOM} $black"  
      git rm -r  "$MOODLE_SRC"/"$DIR"/"$NOM"
      [ $? -ne 0 ] && error=1 &&  echo "git rm -r $DIR/$NOM} "  
      git commit -m "Suppression du plugin $PLUGIN"  
      [ $? -ne 0 ] && error=1 &&  echo "$red error git commit $black" 
      echo "$green $PLUGIN supprimmé de la base de code $black"  
      echo -e "Press any key \n"
      read -rn 1 c
      sortie=0
    else
      echo "$yellow Plugin $PLUGIN n'est pas présent nothing to do! $black"     
    fi
  else
   echo "Abandon !"  
  fi

info "$FUNCNAME" Fin
}

pluginslist () {
  error=0
  PLUGINS=$(yq '.plugins | keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do
    echo "  check plugin: $PLUGIN"
    [[ "$PLUGIN" =~ ^\-.* ]] && continue

    PLUGIN=$(whiptail --title "Suppression d'une version" --menu "$CURRENT" 20 100 "$ARLENGTH" "$LIST[@]" 3>&1 1>&2 2>&3)
    exitstatus=$?
    if [ $exitstatus = 0 ]; then 
      #PLUGIN=$(whiptail --title "ADELE ${PROJECT}" --inputbox "PLUGIN ? " 10 60 "${PLUGINSAVE}" 3>&1 1>&2 2>&3)
      echo " Suppression du plugin ${PLUGIN}"         
      if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Suppression du plugin ${PLUGIN}" 10 60) then
        set_plugin "$PROJECT" "$PLUGIN"
        if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then        
          cd "$MOODLE_SRC" || exit 1
          echo "$green plugin ${NOM} present dans le dossier $DIR $black" 
          git subrepo clean "$dir"/"$nom"
          [ $? -ne 0 ] && error=1 &&  echo "$red error git subrepo clean ${DIR}/${NOM} $black"  
          git rm -r  "$DIR"/"$NOM"
          [ $? -ne 0 ] && error=1 &&  echo "git rm -r $DIR/$NOM} "  
          git commit -m "Suppression du plugin $PLUGIN"  
          [ $? -ne 0 ] && error=1 &&  echo "$red error git commit $black" 
          echo "$green $PLUGIN supprimmé de la base de code $black"  
   
          echo -e "Press any key \n"
          read -rn 1 c
          sortie=0
        else
          echo "Plugin $PLUGIN n'est pas installé!"
          sortie=1
        fi
      else
       echo "Abandon !"  
      fi
    else
      echo "Annulé!"
    fi 
  done 
   
}

 nothingtodo () {
  error=0
  export sortie
  echo 'nothing to do..'
  sortie=0
  echo -e "Press any key \n"
  read -nr 1 c
 }

help () {
  info "$FUNCNAME" Début
  pandoc -s -f markdown -t man README.md | groff -T utf8 -man | less
  info "$FUNCNAME" Fin
}