#!/bin/bash

RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELOW=$(tput setaf 3)
BLUE=$(tput setaf 14)
NC=$(tput sgr 0)

function info() { echo "${BLUE}${@}${NC}"; }
function warn() { echo "${YELOW}${@}${NC}"; }
function error() { echo "${RED}${@}${NC}"; }
function success() { echo "${GREEN}${@}${NC}"; }


function get_pluglist () {
  info Start  "$FUNCNAME"
  local diff now loadfile
  loadfile=false
  if [ -f "$SCRIPT_DIR"/pluglist.json ]; then
    now=$(date +'%Y-%m-%d')
    [[ $(stat "$SCRIPT_DIR"/pluglist.json | grep -E ^.*Modify:.*$) =~ ^.*Modify:.([0-9]{4}-[0-9]{2}-[0-9]{2}).*$ ]] && filedate="${BASH_REMATCH[1]}"
    let diff=($(date +%s -d "$now") - $(date +%s -d "$filedate"))/86400
    [ "$DEBUG" = true ] && info Diff days: $diff  
    [[ $diff -gt "$DIFF_DAYS" ]] && loadfile=true
  else  
    [ "$DEBUG" = true ] && info load file "$SCRIPT_DIR"/pluglist.json: "$loadfile"
    loadfile=true
  fi 
  
  [[ $"$loadfile" = true ]] && wget download.moodle.org/api/1.3/pluglist.php -O "$SCRIPT_DIR"/pluglist.json
  info End  "$FUNCNAME"
}

load_cnf () {  
  error=0
  PROJECT="$1"
  [ "$DEBUG" = true ] && info Start  "$FUNCNAME" "$PROJECT"  
  PROJECTS_PATH_PROJECT="$PROJECTS_PATH"/"$PROJECT"
  [ -f "${PROJECTS_PATH_PROJECT}/${PROJECT}.yml" ] || (error "${PROJECTS_PATH_PROJECT}/${PROJECT}.yml non défini"&&exit 1)
  yq . "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml >/dev/null
  [ $? -eq 1 ]&& error Erreur syntaxe fichier configuration du projet&&error Fichier configuration "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml incorrect&&return 1 
 
  MOODLE_VERSION=$(yq .moodle.version   "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # la branche de la version MOODLE majeure est obtenue par moodle-version.yml
  MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  if [[ "$MOODLE_BRANCH" != null  ]]; then
    [ "$DEBUG" = true ] && echo "Moodle ${MOODLE_MAJOR_VERSION} Branch: $MOODLE_BRANCH" 
  else
    error "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" 
    error=1    
  fi
  
  # validation MOODLE_VERSION
  # MOODLE_VERSION must exists in moodle-version.yml
  # 4.5   latest available relesae in branch
  # 4.5+  Latest available release in branch with fixes
  # 4.5.1 specific release version
  MOODLE_CURRENT=''
  if [ -d "$MOODLE_SRC" ];then
    cd  "$MOODLE_SRC"|| exit 1
    if [[ $MOODLE_VERSION =~ ^4\.[0-5]$ ]]
    then
    #for example 4.5
      [ "$DEBUG" = true ] && info "Latest available release $MOODLE_VERSION"    
      echo "latest available release $MOODLE_VERSION"
      tags=$(git tag -l v"$MOODLE_VERSION"?)
      [ -z $tags ] && error Tags are missing!  && exit 1
      echo $tags    
      MOODLE_CURRENT=v${tags##*v}    
    elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\+$ ]]
    then
    #for example 4.5+
      [ "$DEBUG" = true ] && info "latest available release with fixes $MOODLE_VERSION"    
      [[ ! $(git checkout $MOODLE_BRANCH --quiet) ]] || error git checkout "$MOODLE_BRANCH"
      MOODLE_CURRENT=$MOODLE_BRANCH
    elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]$ ]]
    then
    #for example 4.5.1
      [ "$DEBUG" = true ] && info "Specific release in $MOODLE_VERSION"    
      echo "specific release $MOODLE_VERSION"
      [[ $(git tag -l "v${MOODLE_VERSION}") ]] || (error "Release $MOODLE_VERSION not exists" && exit 1)   
      MOODLE_CURRENT=v$MOODLE_VERSION
    elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]\+$ ]]
    then
      error specific release with fixes in "$MOODLE_VERSION" not yet supoorted...&& error=1
    else
      error Valeur incorecte "$MOODLE_VERSION" && error=1
    fi  
  fi
  PROJECT_BRANCH="$PROJECT"
  
  [[ -z "$DEPOT_ORIGIN" ]] && DEPOT_ORIGIN=$MOODLE_HQ
    
  [ "$DEBUG" = true ] && echo "MOODLE_VERSION: $MOODLE_VERSION"
  [ "$DEBUG" = true ] && echo "MOODLE_MAJOR_VERSION: $MOODLE_MAJOR_VERSION"
  [ "$DEBUG" = true ] && echo "MOODLE_CURRENT: $MOODLE_CURRENT"
  [ "$DEBUG" = true ] && echo "DEPOT_ORIGIN: $DEPOT_ORIGIN"
  [ "$DEBUG" = true ] && echo "PROJECT_BRANCH: $PROJECT_BRANCH"
 
  [ "$DEBUG" = true ] && info End "$FUNCNAME""$PROJECT"
  return $error

}

create_file () {
  error=0
  if [ ! -f "$1" ];then
    touch "$1"
  fi
}

create_dir () {
  error=0
  if [ ! -d "$1" ];then
    mkdir -p "$1"
  fi
}

verif_pre_requis () {
  info Start  "$FUNCNAME"
  local errorS
  error=0
  git --version || error=1  
  jq --version || error=1
  yq --version || error=1
  [ $error -eq 0 ] && success Pre requis satisfied || error Pre requis not satisfied

  info End  "$FUNCNAME"
  return $error
}

create_env () {
   
  # Initialisation signal erreur PROJECT_PATH
  error=0

  create_dir "$DEPOT_MODULES"
  create_dir "$PROJECTS_PATH" 
  create_file save.var
  # création projet demo
  
  PROJECT='demo'

  info End "$FUNCNAME"
   
}

new_project () {
  
  info Start  "$FUNCNAME"
  # Initialisation signal erreur PROJECT_PATH
  error=0
  PROJECT="$1"
  PROJECTS_PATH_PROJECT="$PROJECTS_PATH"/"$PROJECT"
  [[ -d "$PROJECTS_PATH_PROJECT" ]] && error "Project ${PROJECT} already exist !" && exit 1

  info Creation environment "$PROJECTS_PATH_PROJECT"
  
  #create_dirs
  
  create_dir "$PROJECTS_PATH_PROJECT"
  create_dir "$PROJECTS_PATH_PROJECT"/env 
  create_dir "$PROJECTS_PATH_PROJECT"/releases

  create_file "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  
  echo "# Configuration de ${PROJECT}" >>  "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  echo "# generated by ${USER} ${DATE_DU_JOUR}" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml 
  

  MOODLE_VERSION=$(whiptail --inputbox "What is your Moodle version?" 8 39 --title "Conf $PROJECT" $MOODLE_VERSION 3>&1 1>&2 2>&3)
  echo "moodle:" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  echo "  version: $MOODLE_VERSION" >> "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  
  PROJECT_BRANCH="$PROJECT"
  echo "" >>"$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
  echo "plugins:" >>"$PROJECTS_PATH_PROJECT"/"$PROJECT".yml
      
  create_dir "$PROJECTS_PATH_PROJECT"/env/dev
  create_file "$PROJECTS_PATH_PROJECT"/env/dev/config.php

  echo "all dirs created"
  # shwo for update PROJECT_PATH
  nano "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml
  
  # vérification du fichier de configuration du projet 
  config_check "$PROJECT"

  while [ $error -ne 0 ];
  do
    nano "${PROJECTS_PATH_PROJECT}"/"${PROJECT}".yml
    load_cnf "$PROJECT" && break || continue
  done
  # compatible only with MOODLE_VERSION # X.X+ 
  [[ $MOODLE_VERSION =~ ^4\.[0-5]\+$ ]] || unset MOODLE_DEPTH

  echo "fichier de configuration ${PROJECTS_PATH_PROJECT}/${PROJECT}.yml ok"
  echo "debug PROJECT $PROJECT"
  create_repo_moodle "$PROJECT"
   
  success "Project environment ${PROJECT} created"
  info End "$FUNCNAME"
}

create_repo_moodle () {

  info Start  "$FUNCNAME"
  # Initialisation signal erreur 
  error=0
  PROJECT="$1"
  load_cnf "$PROJECT" || exit 1

  if [ -d $MOODLE_SRC ]; then
    info "$MOODLE_SRC" already exists!
    cd $MOODLE_SRC || exit 1

    if [[ ! $(git branch --list | grep "^.*$MOODLE_BRANCH") ]];then
      info "Branch $MOODLE_BRANCH not exists create branch"
      git remote set-branches upstream "$MOODLE_BRANCH"
      [ $? -ne 0 ] && error=1 &&  error git remote set-branches upstream "$MOODLE_BRANCH"&& exit 1
      git fetch upstream "$MOODLE_BRANCH"
      [ $? -ne 0 ] && error=1 &&  error git fetch upsteam "$MOODLE_BRANCH"&& exit 1
      git branch "$MOODLE_BRANCH" upstream/"$MOODLE_BRANCH"
      [ $? -ne 0 ] && error=1 &&  error git branch "$MOODLE_BRANCH" upstream/"$MOODLE_BRANCH"&& exit 1
      # git fetch --tags upstream 
    fi

  else 

   info $MOODLE_SRC does not exists
    if [ -z ${MOODLE_DEPTH+x} ]; then
     info MOODLE_DEPTH is unset
     git clone --branch $MOODLE_BRANCH $DEPOT_ORIGIN  $MOODLE_SRC
    else 
      info "MOODLE_DEPTH is set to $MOODLE_DEPTH"
      git clone --depth="$MOODLE_DEPTH" --branch "$MOODLE_BRANCH" "$DEPOT_ORIGIN"  "$MOODLE_SRC"
    fi
    [ $? -ne 0 ] && error=1 &&  error "git clone $DEPOT_ORIGIN"&& exit 1  
    
    cd $MOODLE_SRC || exit 1
    
    if [ $DEPOT_ORIGIN == $MOODLE_HQ ]; then
      info rename upstream $MOODLE_SRC
      git remote rename origin upstream
      [ $? -ne 0 ] && error=1 &&  error git remote rename origin upstream && exit 1      
    else
      git remote add upstream $MOODLE_HQ
      [ $? -ne 0 ] && error=1 &&  error git remote add origin "$MOODLE_HQ"&& exit 1         
    fi
  fi
  
  set_moodle_current $PROJECT

  # création de la branch projet
  cd $MOODLE_SRC || exit 1
 
  if [[ "$(git branch)" != *"${PROJECT_BRANCH}"* ]]; then
    info "Create Branch ${PROJECT_BRANCH} from ${MOODLE_CURRENT}"
    git branch "${PROJECT_BRANCH}" "${MOODLE_CURRENT}" &&info git branch "$PROJECT_BRANCH" from "$MOODLE_CURRENT" || exit 1  
  fi
  
  git checkout "${PROJECT_BRANCH}" --quiet || (error "Error creation ${PROJECT_BRANCH} ${MOODLE_CURRENT}" && exit 1)  
  
  info End "$FUNCNAME"

}

set_moodle_current () {
  
  info Start  "$FUNCNAME"
  # Initialisation signal erreur 
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  cd $MOODLE_SRC || exit 1

  git checkout $MOODLE_BRANCH --quiet
  [ $? -ne 0 ] && error erreur  git checkout "$MOODLE_BRANCH" && exit 12
  # input MOODLE_VERSION
  # output MOODLE_CURRENT

  # MOODLE_VERSION must exists in moodle-version.yml
  # 4.5   latest available release in branch
  # 4.5+  Latest available release in branch with fixes
  # 4.5.1 specific release version

  # echo "Version Moodle majeure: ${MOODLE_VERSION:0:3}"  
  
  # echo MOODLE_BRANCH: "$MOODLE_BRANCH"plugins.yml
  # #echo "MOODLE_VERSION: $MOODLE_VERSION"
  # MOODLE_MAJOR_VERSION="${MOODLE_VERSION:0:3}"
  # echo "MOODLE_MAJOR_VERSION: $MOODLE_MAJOR_VERSION"
  # MOODLE_BRANCH=$(yq '."'${MOODLE_MAJOR_VERSION}'".branch' "$RACINE"/moodle-version.yml)
  # [[ "$MOODLE_BRANCH" != null ]] && echo "Moodle ${MOODLE_MAJOR_VERSION} Branch: $MOODLE_BRANCH" || echo "Version ${MOODLE_MAJOR_VERSION} non définie dans moodle-version.yml" && exit 1

  
  if [[ $MOODLE_VERSION =~ ^4\.[0-5]$ ]]
  then
    #for example 4.5
    echo "latest available release $MOODLE_VERSION"
    tags=$(git tag -l v"$MOODLE_VERSION"?)
    [ -z $tags ] && error Tags are missing!  && exit 1
    echo $tags    
    MOODLE_CURRENT=v${tags##*v}    
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\+$ ]]
  then
    #for example 4.5+
    echo "latest available release with fixes $MOODLE_VERSION"
    [[ ! $(git checkout $MOODLE_BRANCH --quiet) ]] || error git checkout "$MOODLE_BRANCH"
    MOODLE_CURRENT=$MOODLE_BRANCH
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]$ ]]
  then
    #for example 4.5.1
    echo "specific release $MOODLE_VERSION"
    [[ $(git tag -l "v${MOODLE_VERSION}") ]] || (error "Release $MOODLE_VERSION not exists" && exit 1)   
    MOODLE_CURRENT=v$MOODLE_VERSION
  elif [[ $MOODLE_VERSION =~ ^4\.[0-5]\.[0-4]\+$ ]]
  then
    echo "specific release with fixes in $MOODLE_VERSION not yet supported" && exit 1    
  else
    echo "Valeur incorecte $MOODLE_VERSION"
  fi  
  
  echo "MOODLE_CURRENT : $MOODLE_CURRENT"
  git checkout "${MOODLE_CURRENT}"  --quiet || (error "git checkout ${MOODLE_CURRENT}" &&exit 1)
  
  info End "$FUNCNAME"
}

update_moodle () {
info Start  "$FUNCNAME"
# Initialisation signal erreur 
error=0
#exec 1> >(logger -s -t $(basename $0)) 2>&1

PROJECT="$1"
load_cnf $PROJECT || exit 1

#set_moodle_current $PROJECT

[ "$DEBUG" = true ] && echo "Parametres:"
[ "$DEBUG" = true ] && echo "  Projet: $PROJECT"
[ "$DEBUG" = true ] && echo "  Version Moodle: $MOODLE_VERSION"
[ "$DEBUG" = true ] && echo "  Branche Moodle: $MOODLE_BRANCH"
[ "$DEBUG" = true ] && echo "  Depot local: $MOODLE_SRC"
[ "$DEBUG" = true ] && echo "  Branche local projet: $PROJECT_BRANCH"
[ "$DEBUG" = true ] && echo "  Moodle courant : $MOODLE_CURRENT"
[ "$DEBUG" = true ] && echo "  Mise à jour depot remote : $MOODLE_UPDATE_ORIGIN" 
# valeur MOODLE_UPDATE_ORIGIN definie dans <nom du PROJECT>.yml

cd "$MOODLE_SRC" || exit 1

echo "Mise à jour $MOODLE_BRANCH depuis upstream"

git fetch upstream "$MOODLE_BRANCH" || (error=1 &&  echo "error git fetch upstream $MOODLE_BRANCH"&& exit 1)
git checkout "$MOODLE_BRANCH" --quiet || (error=1 &&  echo "error git checkout $MOODLE_BRANCH"&& exit 1)
git merge --ff-only  upstream/"$MOODLE_BRANCH" || (error=1 &&  error "git merge --ff-only  upstream/$MOODLE_BRANCH "&& exit 1)

echo "Mise jour $MOODLE_BRANCH depuis upstream effectuée"

# determine Moodle release  
echo "set MOODLE $MOODLE_CURRENT"
git checkout $MOODLE_CURRENT --quiet || (error=1 &&  echo "error git checkout $MOODLE_CURRENT"&& exit 1)

head="$(git rev-parse HEAD)"
echo "commit head $head"

ancestor="$(git merge-base ${PROJECT_BRANCH} HEAD)"
echo "commit ancestor $ancestor"
if [[ $head != $ancestor ]]; then
  # git checkout "${PROJECT_BRANCH}" --quiet
  # git rebase "${MOODLE_CURRENT}"
  # echo "git rebase branch project ${head}"
  git checkout "${PROJECT_BRANCH}" --quiet 
  git merge "${MOODLE_CURRENT}"
  info "git merge ${MOODLE_CURRENT} branch project ${PROJECT_BRANCH}"
else
  info "nothing to do already up to date!"
fi

success "$FUNCNAME updated successfully" 
echo

}

list_plugin_cache () {
  error=0
  list=$(ls -l "$DEPOT_MODULES" | grep ^.*moodle-.* | awk '{print $9}')
  whiptail --title "Plugins cache" --menu "Plugin List" 25 78 16 $list
  #[[ "$?" == 0 ]] || error Abandon && exit  
  sortie=0
}

add_plugin_cache () {
  
  info Start  "$FUNCNAME"
  error=0
  [ -z "$1" ]&& PLUGIN="$1" || PLUGIN="moodle-"
  parm=$(whiptail --inputbox "New plugin?" 8 39 "$PLUGIN" --title "Add plugin" 3>&1 1>&2 2>&3)
  # A trick to swap stdout and stderr.
  # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
  exitstatus=$?

  if [ $exitstatus -ne 0 ]; then    
    error "Select canceled."
    exit 1 
  fi
  # en parametre le plugin recherché sous la forme moodle-<type>_<name>
  # ou abbrégée  <type>_<name
  
  [ -z $parm ] && error "$parm" Parametre plugin missing && exit
  [[ "$parm" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}" || component_name="$parm"
  PLUGIN='moodle-'"$component_name"
  [ "$DEBUG" = true ] && info Import: "$PLUGIN"
  if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then
    warn $PLUGIN already exists    
  else
    if [[ "$PLUGIN" =~ ^moodle-([a-z]*)_(.*)$ ]]; then
      type="${BASH_REMATCH[1]}"
      [ "$DEBUG" = true ] && info type: "$type"
      name="${BASH_REMATCH[2]}"
      [ "$DEBUG" = true ] && info name: "$name"
      dir=$(jq -r .plugintypes.${type} "$SCRIPT_DIR"/types.json)
      if [ $dir == null ]; then
        error type: "$type" invalide
        exit    
      fi   
    else
      error "syntax error must be [moodle-]<type>_<name>"
      exit
    fi
  
    # Recherche dans le fichier de référence
  
    jq -r --arg plugin  "$component_name" '.plugins| map(select(.component == $plugin)) | .[]' "$SCRIPT_DIR"/pluglist.json > "$RACINE"/tmp.json
    var=$(jq '.id' "$RACINE"/tmp.json)
    [ ! $var == '' ] && info "$component_name" found "$var" || error nothing found
    NAME=$(jq -r '.name' "$RACINE"/tmp.json)
    SOURCE=$(jq -r '.source' "$RACINE"/tmp.json)  
    [[ $SOURCE  =~ ^.*\/\/.*\/.*\/(.*)$ ]] && echo "${BASH_REMATCH[1]}"
  
    # Add plugin 
    info Source: "$SOURCE"
    if [[ ! $SOURCE ]]; then 
      error "$PLUGIN" non trouvé
      SOURCE=$(whiptail --inputbox "Source du plugin?" 8 39 "https://github.com//$PLUGIN" --title "Project" 3>&1 1>&2 2>&3)
    # A trick to swap stdout and stderr.
    # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
      exitstatus=$?
      if [ $exitstatus -ne 0 ]; then    
        error "Select canceled."
        exit 1 
      fi    
      info Source du plugin "$PLUGIN":"$SOURCE"
    fi

    cd "$DEPOT_MODULES" || exit
    git clone "$SOURCE" $PLUGIN --quiet
    [ $? -ne 0 ] && error erreur git clone "$SOURCE" "$PLUGIN" && exit 9
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
    git remote rename origin upstream
    [ $? -ne 0 ] && error erreur git remote rename origin  upstream && exit 12
  #LAST_PLUGIN="$PLUGIN"
  #[ "$DEBUG" = true ] && info Last_plugin: "$LAST_PLUGIN"
  
  fi
success "$PLUGIN locally loaded in cache"
info End "$FUNCNAME"

}

add_plugin_project () {

  info Start  "$FUNCNAME"
  error=0  
  [ ! -f "$PROJECTS_PATH"/"$1"/"$PROJECT".yml ] && error "$1" n existe pas && exit 1
  PROJECT="$1"
  echo 'debug $2:' $2
  
  parm="$2"
  [ "$DEBUG" = true ] && info PROJET: "$PROJECT" plugin: "$PLUGIN"
  parm=$(whiptail --inputbox "New plugin?" 8 39 "$parm" --title "$PROJECT" 3>&1 1>&2 2>&3)
  # A trick to swap stdout and stderr.
  # Again, you can pack this inside if, but it seems really long for some 80-col terminal users.
  exitstatus=$?

  if [ $exitstatus -eq 0 ]; then
    [[ "$parm" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}" || component_name="$parm"
    PLUGIN='moodle-'"$component_name"     
    if [[ -d "$DEPOT_MODULES"/"$PLUGIN" ]]; then    
      if [[ ! $(cat "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml) =~ ^.*"$PLUGIN".*$ ]]; then      
        cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
        [[ "$PLUGIN" =~ ^moodle-(.*)$ ]] && component_name="${BASH_REMATCH[1]}"
        jq -r --arg plugin  "$component_name" '.plugins| map(select(.component == $plugin)) | .[]' "$SCRIPT_DIR"/pluglist.json > "$RACINE"/tmp.json
        var=$(jq '.id' "$RACINE"/tmp.json)
        [ ! $var == '' ] && info "$var" || error nothing found
        NAME=$(jq -r '.name' "$RACINE"/tmp.json)
        SOURCE=$(jq -r '.source' "$RACINE"/tmp.json)  
        [[ $SOURCE  =~ ^.*\/\/.*\/.*\/(.*)$ ]] && echo "${BASH_REMATCH[1]}"
        if [[ ! "$SOURCE" ]]; then           
           url=$(cat .git/config | grep -E "^.*url.*$")
           [ "$DEBUG" = true ] && info url: "$url"
           [[ "$url"  =~ ^.*(https:.*)$ ]] && SOURCE="${BASH_REMATCH[1]}"
        fi
        echo "" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        echo "  $PLUGIN:" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        echo "    name: $NAME" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        echo "    source: $SOURCE" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        select_plugin_branch "$PROJECT" "$PLUGIN"
        echo "    branch: $PLUGIN_BRANCH" >> "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
        nano "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml
      else
        error "$PLUGIN" already in plugins list
        error=1
      fi 
    else
      error "$PLUGIN" not already imported
      error=1
    fi
  else
    error "Select canceled."
    error=1 
  fi
  
  info End "$FUNCNAME"
}

select_plugin_branch () {
  info Start  "$FUNCNAME"
  PROJECT="$1"
  PLUGIN="$2"
  PLUGIN_BRANCH=''
  load_cnf "$1"

  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1

  [ "$DEBUG" = true ] && info Branche Moodle: "$MOODLE_BRANCH"
  info "Plugin: $PLUGIN"

  local found
  found=false
  if [[ $(git branch -r | grep -E "^  upstream\/$MOODLE_BRANCH$") ]]; then
      PLUGIN_BRANCH="$MOODLE_BRANCH"
      info "Bingo Moodle branch $MOODLE_BRANCH match !"
      found=true
  else 
      branch_stable_remote=$(git branch -r | grep -E "^  upstream\/MOODLE_[0-9]{2,3}_STABLE$" | sort -rn | head -n 1)
      info "default best highest remote branch $branch_stable_remote"
      if [[ "$branch_stable_remote" ]]; then        
        if [[ $branch_stable_remote =~ ^.*upstream\/(.*)$ ]]; then
          PLUGIN_BRANCH="${BASH_REMATCH[1]}"
          found=true
        fi
      fi 
  fi
  
  if [ $found = false ]; then  
    if [[ $(git rev-parse --verify upstream/master 2>/dev/null) ]]; then      
      PLUGIN_BRANCH=master
      found=true
      info Branch remote master exists
    elif [[ $(git rev-parse --verify upstream/main 2>/dev/null) ]]; then      
      PLUGIN_BRANCH=main
      found=true
      info Branch remote main selectionnée
    fi
  fi
  
  if [ $found = true ]; then
    if [[ $(git rev-parse --verify "$PLUGIN_BRANCH" 2>/dev/null) ]]; then
     info "$PLUGIN_BRANCH selected exists"
    else 
      git branch "$PLUGIN_BRANCH" remotes/upstream/"$PLUGIN_BRANCH"
      info "$PLUGIN_BRANCH" créée
    fi
  fi 
  [[ "$PLUGIN_BRANCH" != null ]]&& git checkout "$PLUGIN_BRANCH" --quiet
  info "$PLUGIN" branch: "$PLUGIN_BRANCH"
  info End "$FUNCNAME"
}

config_check () {
  info Start "$FUNCNAME"
  error=0
  PROJECT="$1"
  # check validity .yml 
  yq "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml >/dev/null  || exit 1
  
  PLUGINS=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do    
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    [[ "$PLUGIN" =~ ^\.*# ]] && continue
    info "Check plugin: $PLUGIN"
    SOURCE=$(yq .plugins."$PLUGIN".source "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)  
    BRANCH_UPSTREAM=$(yq .plugins."$PLUGIN".branch "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)  
    PLUGIN_VERSION=$(yq .plugins."$PLUGIN".version "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
    LOCALDEV=$(yq .plugins."$PLUGIN".localdev "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
    #if LOCALDEV not defined set to null
    if [[ "$PLUGIN_VERSION" != null ]]; then    
      BRANCH_PLUGIN="$PLUGIN_VERSION"
      [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN  from PLUGIN_VERSION not null: $PLUGIN_VERSION"
    elif [[ "$LOCALDEV" != 'null' ]]; then
      BRANCH_PLUGIN="$LOCALDEV"
      [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN from LOCALDEV not null: $LOCALDEV"
    elif [[ "$BRANCH_UPSTREAM" != 'null' ]]; then
      BRANCH_PLUGIN="$BRANCH_UPSTREAM"
      [ "$DEBUG" = true ] && echo "  BRANCH_UPSTREAM: $BRANCH_PLUGIN from plugin's branch: $BRANCH_UPSTREAM"
    else
      error Manque definition version "$PLUGIN"
      error=1
    fi      
  done
  
  [ $error == 0 ] && success Configuration file "$PROJECT" successful || error Please correct configuration file and retry
  
  info End "$FUNCNAME"
}

edit_plugins () { 
  
  info Start  "$FUNCNAME"
  error=0
  PROJECT="$1"
  load_cnf $PROJECT || exit 1
  PROJECTS_PATH_PROJECT="$RACINE"/projects/"$PROJECT"
  local date_before date_after 
  date_before=$(date -r "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  pluginsbefore=$(yq 'select(.plugins)|.plugins|keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo "Nb plugins avant maj : ${#pluginsbefore[@]}"

  nano "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml

  date_after=$(date -r "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  if [ "$date_after" != "$date_before" ]; then
     [ "$DEBUG" = true ] && echo "il y a eu des maj..."
    # check validity .yml 
    yq "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml >/dev/null || exit 1
    pluginsafter=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
    [ "$DEBUG" = true ] && echo "Nb plugins apres maj : ${#pluginsafter[@]}"
    # on ne récupere que les plugins uniques donc uniquement ceux supprimés et non aussi ceux ajoutés !
    plugins_suppress=($(echo ${pluginsbefore[@]} ${pluginsafter[@]} ${pluginsafter[@]} | tr ' ' '\n' | sort | uniq -u))
    [ "$DEBUG" = true ] && echo "nb plugins à supprimmer: ${#plugins_suppress[@]}"
    for key in "${!plugins_suppress[@]}"; do    
      # skip first entry -  
      [[ ${plugins_suppress[$key]} == '-' ]] && continue
      echo "A supprimmer: $key ${plugins_suppress[$key]}"
      suppress_plugin "$PROJECT" "${plugins_suppress[$key]}"
    done
    config_check "$PROJECT"
    update_codebase "$PROJECT"
    success Code base updated
  else
    echo "Pas de modification de la liste des plugins"
  fi  

  info End "$FUNCNAME"

}

update_repo () {  
  
  info Start  "$FUNCNAME"   
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1 
  PLUGINS=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do    
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    info "Check plugin: $PLUGIN"
    if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then	   
      upgrade_plugin "$PROJECT" "$PLUGIN"
    else
      import_plugin "$PROJECT" "$PLUGIN"
    fi
  done

  info End "$FUNCNAME"

}

upgrade_plugin () {
  
  info Start  "$FUNCNAME"
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
  cd $DEPOT_MODULES/$PLUGIN || exit 1
   
  set_plugin "$PROJECT" "$PLUGIN"
  
  git checkout --quiet $BRANCH_PLUGIN ||(error "Banch $BRANCH_PLUGIN not exists" && exit 1)

  if [[ $PLUGIN_VERSION == null ]]; then    

    # SITEREMOTE=$(git remote | grep 'upstream')
    # [ $SITEREMOTE != 'upstream' ] && error=1 && echo "$red site remote upstream missing $black" && exit 1
    
    git fetch --quiet upstream || (error=1 &&  error "Error git fetch upstream")
    git show-ref --verify --quiet refs/heads/"$BRANCH_UPSTREAM" || (error=1 &&  error "Error  git show-ref ref/heads/$BRANCH")   
     
    BRANCHREMOTE=$(git rev-parse --abbrev-ref $BRANCH_UPSTREAM@{upstream})
    [ "$DEBUG" = true ]&&echo "branche remote : $BRANCHREMOTE" 
     
    LOCAL=$(git rev-parse @)
    REMOTE=$(git rev-parse @{u})
    BASE=$(git merge-base @ @{u})
    
    [ "$DEBUG" = true ]&&echo LOCAL:  "$LOCAL"
    [ "$DEBUG" = true ]&&echo REMOTE: "$REMOTE"
    [ "$DEBUG" = true ]&&echo BASE:   "$BASE"

    if [ "$LOCAL" = "$REMOTE" ]; then
      success "$PLUGIN branche $BRANCH up-to-date with remote $BRANCHREMOTE"
    elif [ "$LOCAL" = "$BASE" ]; then           
      warn "$BRANCH_UPSTREAM need to pull from remote $BRANCHREMOTE" 
      # git fetch --quiet upstream
      # [ $? -ne 0 ] && error=1 &&  echo "$red error git fetch --quiet upstream $black" && exit 1
      if [ "$PLUGIN_UPGRADE_AUTO" == true ];then        
        info "Mise à jour automatique du plugin $PLUGIN"
        git fetch --quiet upstream || (error "$Error git checkout --quiet upstream" && exit 1)
        git checkout --quiet $BRANCH_UPSTREAM || (error=1 &&  error "$Error git checkout --quiet $BRANCH_UPSTREAM" && exit 1)
        git merge --quiet --ff-only upstream/$BRANCH_UPSTREAM || (error=1 &&  error "Error git merge --quiet --ff-only upstream/$BRANCH_UPSTREAM" && exit 1)
         
        if [ $LOCALDEV != null ]; then 
          EXISTS=$(git show-ref refs/heads/"$LOCALDEV")
          if [[ -z $EXISTS ]]; then
            git branch --quiet $LOCALDEV $BRANCH_UPSTREAM || (error=1 &&  error "Error git branch --quiet $LOCALDEV $BRANCH_UPSTREAM" && exit 1)
          fi
          git checkout --quiet "$LOCALDEV" || (error=1 &&  error "Error git checkout $LOCALDEV" && exit 1)
          git rebase --quiet "$BRANCH_UPSTREAM"
          if [ $? -eq 0 ]; then
            success "$LOCALDEV git rebase $BRANCH_UPSTREAM successfull"
          else 
            error "error $LOCALDEV git rebase $BRANCH_UPSTREAM" && exit 1
          fi
        fi
      fi
    elif [ "$REMOTE" == "$BASE" ]; then           
        warn "$BRANCH_UPSTREAM need to push to remote $BRANCHREMOTE"
    else           
        error "$BRANCH_UPSTREAM diverged with remote $BRANCHREMOTE !!!" && exit 1
    fi
  else
    # cas pinned version     
    # check contains 

    if [[ 0 -eq $(git merge-base --is-ancestor "$PLUGIN_VERSION" HEAD) ]]; then
      success "$PLUGIN / $BRANCH_PLUGIN contains pinned version $PLUGIN_VERSION"
     else
      error=1
      error "$BRANCH_PLUGIN does not contains pinned version $PLUGIN_VERSION"
      exit
    fi

    git reset --hard "$PLUGIN_VERSION"
    [ $? -ne 0 ] && error=1 &&  error "Error git reset --hard $PLUGIN_VERSION" && exit 1
  fi

  info End "$FUNCNAME"
}

import_plugin () {

  info Start  "$FUNCNAME" 
  
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
  [ "$DEBUG" = true ]&& info "debug $FUNCNAME $PROJECT $PLUGIN $DEPOT_MODULES"
  set_plugin "$PROJECT" "$PLUGIN" 
  cd "$DEPOT_MODULES" || exit 1  
  git clone  "$SOURCE" "$PLUGIN" --quiet
  [ $? -ne 0 ] && erreur git clone "$SOURCE" "$PLUGIN" && exit 9

  cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
  # if plugin contains submodules initialize and update
  if [ -d .gitmodules ]; then
    git submodules --init
    [ $? -ne 0 ] && error erreur git submodules init && exit 12
  fi
  git remote rename origin upstream
  [ $? -ne 0 ] && error erreur git remote rename origin  upstream && exit 12
    
  git checkout "$BRANCH_UPSTREAM" --quiet
  if [[ $? -ne 0 ]]; then
    echo creation branche "$BRANCH_UPSTREAM"
    git branch '$BRANCH_UPSTREAM" remotes/upstream/"$BRANCH_UPSTREAM' --quiet
    [ $? -ne 0 ] && error "Error git branch --quiet remotes/upstream/$BRANCH_UPSTREAM" && exit 13
    git checkout "$BRANCH_UPSTREAM" --quiet
    [ $? -ne 0 ] && error "Error git checkout --quiet $BRANCH_UPSTREAM" && exit 14
  fi
  
  if [[ "$PLUGIN_VERSION" != null ]]; then
    [ "$DEBUG" = true ]&&echo PLUGIN_VERSION: "$PLUGIN_VERSION"
    git checkout "$PLUGIN_VERSION" --quiet || (error "$PLUGIN_VERSION is not tag nor commit of plugin $PLUGIN" && exit 1)
    BRANCH_PLUGIN="$PLUGIN_VERSION"
  elif [[ "$LOCALDEV" != null ]]; then
    if [[ "$(git branch)" != *"${LOCALDEV}"* ]]; then
      echo "Create Branch ${LOCALDEV} from ${BRANCH_UPSTREAM}"
      git branch "${LOCALDEV}" "${BRANCH_UPSTREAM}" || (error "Error git branch ${LOCALDEV} ${BRANCH_UPSTREAM}" && exit 1)  
      success "Branch localdev $LOCALDEV created "
    fi
    BRANCH_PLUGIN="$LOCALDEV"
  else
     BRANCH_PLUGIN="$BRANCH_UPSTREAM"  
  fi
  # verification avant de quitter
  set_plugin "$PROJECT" "$PLUGIN"
  git checkout $BRANCH_PLUGIN --quiet || (error "Error git checkout ${BRANCH_PLUGIN}" && exit 1) 
  
  # if [[ $LOCALDEV != null ]]; then
  #   git branch "$LOCALDEV" "$BRANCH_UPSTREAM"  --quiet
  #   [ $? -ne 0 ] && echo "$red erreur git checkout --quiet $BRANCH_UPSTREAM $black" && exit 1
  #   echo "$green branch localdev $LOCALDEV created $black" && exit 1
  # fi
  
  # if [[ $PLUGIN_VERSION != null ]]; then
  #     set_version
  # fi 
  
  [ "$DEBUG" = true ]&& echo "$PLUGIN" type: "$TYPE" dir: "$DIR"
  success "$UNAME cloned under name $PLUGIN in local repo $DEPOT_MODULES"
  
  info End "$FUNCNAME"
}

set_plugin () {  

  [ "$DEBUG" == true ] && info Start  "$FUNCNAME" "$PLUGIN"
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN="$2"
 
  SOURCE=$(yq .plugins."$PLUGIN".source "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)  
  BRANCH_UPSTREAM=$(yq .plugins."$PLUGIN".branch "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)  
  PLUGIN_VERSION=$(yq .plugins."$PLUGIN".version "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  LOCALDEV=$(yq .plugins."$PLUGIN".localdev "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  #if LOCALDEV not defined set to null
  if [[ "$PLUGIN_VERSION" != null ]]; then    
    BRANCH_PLUGIN="$PLUGIN_VERSION"
    [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN  from PLUGIN_VERSION not null: $PLUGIN_VERSION"
  elif [[ "$LOCALDEV" != 'null' ]]; then
    BRANCH_PLUGIN="$LOCALDEV"
    [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN from LOCALDEV not null: $LOCALDEV"
  else
    BRANCH_PLUGIN="$BRANCH_UPSTREAM"  
    [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN from default plugin's branch: $BRANCH_UPSTREAM"
  fi  
  if [ -d "$DEPOT_MODULES"/"$PLUGIN" ]; then
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1
    git checkout "$BRANCH_PLUGIN" --quiet
    [ $? -ne 0 ] && error git checkout "$BRANCH_PLUGIN" && exit 1
    BRANCH_PLUGIN_SHA1=$(git rev-parse HEAD)
  fi
  # DIR inclusion

  ss=${PLUGIN#*-}
  NOM=${PLUGIN#*_}
  TYPE=${ss%%_*}

# le fichier components.json permet de determiner le reprtoire de destination a partir du nom du plugin
# pour convertir au format yaml : yq -oy components.json > components.yml

  #DIR=$(jq .plugintypes.$TYPE $RACINE/components.json | tr -d '"') 
  
  DIR=$(yq ".plugintypes.$TYPE" "$RACINE"/components.yml)
  if [[ $DIR == 'null' ]];
    then error=1 && error "Prefixe $TYPE  unkown" exit 1    
  fi

  [ "$DEBUG" = true ] && echo "  PLUGIN: $PLUGIN"   
  [ "$DEBUG" = true ] && echo "  BRANCH_UPSTREAM: $BRANCH_UPSTREAM"
  [ "$DEBUG" = true ] && echo "  LOCALDEV: $LOCALDEV"  
  [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN: $BRANCH_PLUGIN"
  [ "$DEBUG" = true ] && echo "  BRANCH_PLUGIN_SHA1: $BRANCH_PLUGIN_SHA1"
  [ "$DEBUG" = true ] && echo "  SOURCE: $SOURCE"
  [ "$DEBUG" = true ] && echo "  PLUGIN VERSION : $PLUGIN_VERSION"
  [ "$DEBUG" = true ] && echo "  DIR : $DIR"

  [ "$DEBUG" = true ] && info End "$FUNCNAME"
} 

subrepo_plugin ()  {
  
  info Start  "$FUNCNAME"
  
  error=0
  PROJECT="$1"
  PLUGIN="$2"
  MSG="$3"
  
  set_plugin "$PROJECT" "$PLUGIN"

  cd "$MOODLE_SRC"
  if [ ! -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then
    mkdir -p "$MOODLE_SRC"/"$DIR"/"$NOM"
  fi
  rsync -a "$DEPOT_MODULES"/"$PLUGIN"/* "$MOODLE_SRC"/"$DIR"/"$NOM"/
  echo "    branch = $BRANCH_PLUGIN" > "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo
  echo "    commit = $BRANCH_PLUGIN_SHA1" >> "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo
  git add .
  [ $? -ne 0 ] && error git add . && exit 1
  git commit -m "$MSG" --quiet
  [ $? -ne 0 ] && error git commit "$MSG" && exit 1
  
  info End "$FUNCNAME"
}

update_codebase () {

  info Start  "$FUNCNAME"
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  # Etape 1 met à jour le depot local de plugin
  update_repo "$PROJECT"
  # Etape 2 met à jour la base de code
    
  cd "${MOODLE_SRC}" || exit 1
  git checkout "${PROJECT_BRANCH}" --quiet || (error git checkout "${PROJECT_BRANCH}" && exit 1)

  PLUGINS=$(yq 'select(.plugins) |.plugins|keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && info PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do
    [[ "$PLUGIN" =~ ^\-.* ]] && continue      
    set_plugin "$PROJECT" "$PLUGIN"  
    info "Check: $PLUGIN branch: $BRANCH_PLUGIN"  
    cd "$DEPOT_MODULES"/"$PLUGIN" || exit 1

  # BRANCH_UPSTREAM branche du plugin dans le depot source
  # BRANCH_PLUGIN branche à utiliser 
  # = BRANCH_UPSTREAM quand il n'y a pas de de local
  # = LOCALDEV  branch de dev local  
  # = PLUGIN_VERSION quand il existe une version explicite du plugin la branche BRANCH_PLUGIN  est crée à ce commit lors de création ou de la mise à jour
    
    git checkout "$BRANCH_PLUGIN" --quiet
    [ $? -ne 0 ] && error=1 &&  error "Error git checkout plugin $PlUGIN_VERSION" && exit 1
  
    LOCAL=$(git rev-parse @)

    if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then
    # module already installed
      cd "$MOODLE_SRC"/"$DIR"/"$NOM" || exit 1     
      #for sha1 complet -c11-50 | cut -c11-50
      #COMMIT=$(grep .gitrepo -e 'commit = ') 
      [[ $(grep .gitrepo -e 'commit = ') =~ ^.*commit' = '([a-f0-9].*)$ ]] && COMMIT="${BASH_REMATCH[1]}" 
            
      if [[ "$COMMIT" == "$LOCAL" ]]; then    
        # MOD='OK'
        success "$PLUGIN est installe dans $MOODLE_SRC/$DIR/$NOM et est à jour OK"
      else     
        # MOD='UPD'
        warn "$PLUGIN est installe dans $MOODLE_SRC/$DIR/$NOM mais n est pas à jour UPD"  
        #echo git subtree pull --prefix=${dir}/${NOM} --squash  $DEPOT_MODULES/$2 ${BRANCHE}
        #echo git subrepo pull ${MOODLE_SRC}/${dir}/${NOM} -b ${BRANCH} 
        cd  $MOODLE_SRC || exit 1 
        # git subrepo pull "$DIR"/"$NOM" -b "$BRANCH_PLUGIN" --message "Update $PLUGIN $BRANCH"
        # [ $? -ne 0 ] && error=1 &&  echo error git subrepo pull $DIR/${NOM} -b ${BRANCH} 
        subrepo_plugin "$PROJECT" "$PLUGIN" "Mise à jour de $PLUGIN"
        success "$PLUGIN mis à jour dans le répertoire $DIR"  
      fi
    else      
      # MOD='ADD' 
      warn "$PLUGIN missing in $MOODLE_SRC/$DIR/$NOM. ADD"
      info "$PLUGIN type: $TYPE path: $DIR branch: $BRANCH_PLUGIN"
      #echo git subtree add --prefix=${dir}/${NOM} --squash  $DEPOT_MODULES/$2 ${BRANCH}  
      #cd  $MOODLE_SRC || exit 1 
      # [ "$DEBUG" = true ]&&echo  git subrepo clone $DEPOT_MODULES/$PLUGIN $DIR/$NOM -b $BRANCH_PLUGIN
      # git subrepo clone --message "Add $PLUGIN $BRANCH_PLUGIN" "$DEPOT_MODULES"/"$PLUGIN" "$DIR"/"$NOM" -b "$BRANCH_PLUGIN"
      # [ $? -ne 0 ] && error=1 &&  echo "$red" error "$DEPOT_MODULES"/"$PLUGIN" "$DIR"/"$NOM" -b "$BRANCH_PLUGIN" "$black" && exit 1  
      subrepo_plugin "$PROJECT" "$PLUGIN" "Add $PLUGIN / $BRANCH_PLUGIN dans le répertoire $DIR"
      info "$PLUGIN / $BRANCH_PLUGIN ajouté dans le répertoire $DIR" 
    fi
  
  done

 info End "$FUNCNAME"

}

release () {

info Start  "$FUNCNAME"
error=0
PROJECT="$1"
info "Project $PROJECT Branch src Moodle: $PROJECT_BRANCH"

load_cnf "$PROJECT" || exit 1
# $2 MSG for new release
[  -z "$2" ] && MSG='cb' || MSG="$2"
NEWRELEASE=$(date +%Y.%m.%d@%Hh%M)
info New release: "$NEWRELEASE"  
cd "$MOODLE_SRC" || exit 1
git checkout "$PROJECT_BRANCH" --quiet 
[ $? -ne 0 ]&& error "Erreur git checkout $PROJECT_BRANCH"&& exit 1
  
git commit --allow-empty -m "$MSG"
[ $? -ne 0 ]&& error "Erreur git commit --allow-empty "&& exit 1

git tag -a "$NEWRELEASE" -m ""
[ $? -ne 0 ]&& error "Erreur git tag $NEWRELEASE" && exit 1

if [ $SAVE_RELEASE == true ]; then
  info Start build "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"
  mkdir -p  "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE" || exit 1
  cp -r $MOODLE_SRC/*   "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"/
  rm -rf "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"/.git
  info End build "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"

  [ -L "$PROJECTS_PATH_PROJECT"/releases/current ] && unlink "$PROJECTS_PATH_PROJECT"/releases/current
  
# ln -s ${RELEASES}/$NEWRELEASE current_temp
# mv -Tf current_temp  ${PROJECTS_PATH_PROJECT}/current

  ln -s "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE" "$PROJECTS_PATH_PROJECT"/releases/current

  info New current relesae: $(readlink "$PROJECTS_PATH_PROJECT"/releases/current) 

# delete old releases

  saved_releases "$PROJECT"

fi

# create <PROJECT>.lock
project_lock "$PROJECT"

if [[ "$MOODLE_UPDATE_ORIGIN" == 'Y' ]]; then
  info "Update $PROJECT_BRANCH in remote repository origin"
  git push origin "$PROJECT_BRANCH"
  [ $? -ne 0 ] && error=1 &&  echo "error git push $PROJECT_BRANCH"&& exit 1
fi

info End "$FUNCNAME"
}

function project_lock () {
 
  PROJECT="$1"
  info Start  "$FUNCNAME" "$PROJECT"
  error=0
  #load_cnf "$PROJECT"  && echo conf $PROJECT successfully loaded || exit
  cd "$PROJECTS_PATH"/"$PROJECT" || exit 1
  # create "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  [ -f "$PROJECT".lock ] && rm "$PROJECT".lock 
  cp "$PROJECT".yml "$PROJECT".lock

  cd "$MOODLE_SRC" || exit 1
  [ "$DEBUG" = true ] && echo "PROJECT_BRANCH: $PROJECT_BRANCH"
  git checkout "$PROJECT_BRANCH" --quiet
  [ "$DEBUG" = true ] && echo $(git rev-parse --abbrev-ref HEAD) $(git rev-parse --short HEAD)
  moodlebranch=$(git rev-parse --abbrev-ref HEAD) yq -i '.moodle.branch=strenv(moodlebranch)' $PROJECTS_PATH/$PROJECT/$PROJECT.lock 
  moodlesha1=$(git rev-parse --short HEAD) yq -i '.moodle.version=strenv(moodlesha1)' $PROJECTS_PATH/$PROJECT/$PROJECT.lock 

  PLUGINS=$(yq 'select(.plugins)|.plugins|keys' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do     
    [[ "$PLUGIN" =~ ^\-.* ]] && continue
    [ "$DEBUG" = true ] &&echo "Check plugin: $PLUGIN"
    set_plugin "$PROJECT" "$PLUGIN"
    [[ $(cat "$MOODLE_SRC"/"$DIR"/"$NOM"/.gitrepo | grep 'commit') =~ .*=.([0-9a-z]+) ]] && commit="${BASH_REMATCH[1]}" 
    pathenv=".plugins.$PLUGIN" commit=${commit:0:7} yq -i 'eval(strenv(pathenv)).version = strenv(commit)' "$PROJECTS_PATH"/"$PROJECT"/"$PROJECT".lock
  done
  info End "$FUNCNAME" "$PROJECT"
  return $error
}

function saved_releases () {

  info Start  "$FUNCNAME"
  cd "$PROJECTS_PATH"/"$PROJECT"/releases
  local nb_releases release
  nb_releases=$(ls -l | wc -l)
  info Nb releases: $nb_releases
  while [ $nb_releases -gt $MAX_RELEASES ]; do
    release=$(ls -tr | head -n 1) 
    rm -r $release && info "$nb_releases delete $release"
    nb_releases=$(ls -l | wc -l)
  done

  info End "$FUNCNAME"

}


deploy () {

  info Start  "$FUNCNAME"
  PROJECT="$1"
  load_cnf "$PROJECT"
  [  -z "$2" ] && RELEASE='current' || RELEASE="$2"
  info Release: "$RELEASE"
  
  DEPLOYMENT_ENV=$(whiptail --inputbox "What is your deployment environnement ?" 8 39 "$DEPLOYMENT_ENV" --title "Project" 3>&1 1>&2 2>&3)
  exitstatus=$?

  if [ $exitstatus = 0 ]; then 
    [ "$DEBUG" = true ] && info DEPLOYMENT_ENV: $DEPLOYMENT_ENV   
    if [ -d "$PROJECTS_PATH"/"$PROJECT"/env/"$DEPLOYMENT_ENV" ]; then    
      info "Deploiement environment: $DEPLOYMENT_ENV"
      cd "$PROJECTS_PATH"/"$PROJECT"/env/"$DEPLOYMENT_ENV" || exit 1  
      source server
      [ "$DEBUG" = true ]&&info "Server: $SERVER"  
      if [ -f "$SERVER"/config.php ]; then
        cp "$SERVER"/config.php ./config.php
      fi
      if [ -f config.php ]; then
        sudo rsync -a --exclude .git "$PROJECTS_PATH"/"$PROJECT"/releases/"$RELEASE"/* "$SERVER"/
        sudo cp config.php "$SERVER"/
        [ "$DEBUG" = true ]&&info config.php copy in "$SERVER"
        # docker exec -it docker_moodle-app  php admin/cli/maintenance.php --enable
        # docker exec -it docker_moodle-app  php admin/cli/upgrade.php
        # docker exec -it docker_moodle-app  php admin/cli/maintenance.php --disable
      else
      [ "$DEBUG" = true ]&&error no config.php
        sudo rsync -a --exclude .git "$PROJECTS_PATH"/"$PROJECT"/releases/"$RELEASE"/* "$SERVER"/
      fi
      info "That's ALL!"
    else
      error "Deploiement environment n'est pas créé $DEPLOYMENT_ENV"
      error=1
    fi
  else
    error "Cancel."
    error=1
  fi 



#  [ -d "$PROJECTS_PATH_PROJECT"/config-php ] || mkdir "$PROJECTS_PATH_PROJECT"/config-php
  

# Mise à jour de config.php
#  si existe on prend ${PROJECTS_PATH_PROJECT}/config-php/config.php" 
#  Sinon on le récupère ${PROJECTS_PATH_PROJECT}/current/config.php 
# sinon rien (sera cree lors de l'installation)

# if [ -e "$PROJECTS_PATH_PROJECT"/config-php/config.php ]; then  
#   echo "Recopie config.php depuis $PROJECTS_PATH_PROJECT/config-php/config.php"   
#   cp "$PROJECTS_PATH_PROJECT"/config-php/config.php "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"/
# elif [ -e "$PROJECTS_PATH_PROJECT"/current/config.php ];  then
#   echo "Recopie config.php depuis derniere release $PROJECTS_PATH_PROJECT/current/config.php si elle existe"
#   cp $PROJECTS_PATH_PROJECT/current/config.php "$PROJECTS_PATH_PROJECT"/releases/"$NEWRELEASE"
#   #et aussi  sauvegarde 
#   cp $PROJECTS_PATH_PROJECT/current/config.php $PROJECTS_PATH_PROJECT/config-php/
# fi

  info End "$FUNCNAME"

}
versionrestore () {
  error=0
  CURRENTVERSION=$(readlink ${PROJECTS_PATH_PROJECT}/current)
  [ "$DEBUG" = true ] && echo Version courente: $CURRENTVERSION 
  cd $RELEASES || exit 1  
  files=(*)
  ARLENGTH=${#files[@]}
  [ "$DEBUG" = true ] && echo "Nb version: $ARLENGTH"
  [[ "${ARLENGTH}" < 2 ]] && echo "il ne reste qu'une version !" && exit 1
  LIST=()
  for ((i=0; i<$ARLENGTH; i++))
    do
      if [[ $RELEASES/${files[$i]} == $CURRENTVERSION ]]; then
        # echo version courante $i 
        # LIST+=(${i}  *${files[$i]}) 
        continue
      else
        echo version autre    $i
        LIST+=($i ${files[$i]})
      fi
  done 

 
  VER=$(whiptail --title "Restoration d'une version" --menu "$CURRENT" 20 100 "${ARLENGTH}" "${LIST[@]}" 3>&1 1>&2 2>&3)
  exitstatus=$?
 
  if [ $exitstatus = 0 ]; then    
    
    NEWCURRENT="${files[${VER}]}"
    echo "Version sélectionnée: $NEWCURRENT"        
    if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Version sélectionnée: $NEWCURRENT" 10 60) then  
      echo VER: $VER
      [ -L "${PROJECTS_PATH_PROJECT}/current" ] && unlink "${PROJECTS_PATH_PROJECT}/current" && echo Suppression du lien current
      ln -s $RELEASES/$NEWCURRENT $PROJECTS_PATH_PROJECT/current
      echo New current: $(readlink "${PROJECTS_PATH_PROJECT}/current") 
    else
        echo "Abandon du traitement"
    fi    
    sortie=0 
  else
      echo "Abandon du traitement"
  fi

}
 
versionsuppress () {
  error=0
  CURRENTVERSION=$(readlink $PROJECTS_PATH_PROJECT/current)
  [ "$DEBUG" = true ] && echo "Version courente: $CURRENTVERSION"
  cd "$RELEASES" || exit 1  
  files=(*)
  ARLENGTH=${#files[@]}
  [ "$DEBUG" = true ] && echo "Nb version: $ARLENGTH"
  [[ "$ARLENGTH" -lt 2 ]] && echo "il ne reste qu'une version !" && exit 1

  LIST=()
  for ((i=0; i < $ARLENGTH; i++))
    do
      if [[ "${RELEASES}"/${files[$i]} == $CURRENTVERSION ]];
      then
        # echo version courante $i "${RELEASES}"/${files[$i]}
        # LIST+=(${i}  *${files[$i]}) 
        continue
      else
        [ "$DEBUG" = true ] && echo version autre    $i "$RELEASES"/${files[$i]}
        LIST+=($i ${files[$i]})
      fi
  done  
 
  VER=$(whiptail --title "Suppression d'une version" --menu "$CURRENT" 20 100 "$ARLENGTH" "$LIST[@]" 3>&1 1>&2 2>&3)
  exitstatus=$?
 
  if [ $exitstatus = 0 ]; then    
    
    SUPPRESS="${files[${VER}]}"
    echo "Version sélectionnée: $SUPPRESS"    
    if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Version sélectionnée: $SUPPRESS" 10 60) then  
      echo Version supprimée: "$SUPPRESS"
      sudo rm -rf "$SUPPRESS"
    else
        echo "Abandon du traitement"
    fi    
    sortie=0 
  else
      echo "Abandon du traitement"
  fi
  
}
suppress_plugin () {

  info Start  "$FUNCNAME"
  error=0
  PROJECT="$1"
  #load_cnf $PROJECT || exit 1
  PLUGIN=$2

  echo " Suppression du plugin ${PLUGIN}" 
        
  if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Suppression du plugin ${PLUGIN}" 10 60) 
  then

    # DIR inclusion

    ss=${PLUGIN#*-}
    NOM=${PLUGIN#*_}
    TYPE=${ss%%_*}

    # le fichier components.json permet de determiner le reprtoire de destination a partir du nom du plugin
    # pour convertir au format yaml : yq -oy components.json > components.yml
    #DIR=$(jq .plugintypes.$TYPE $RACINE/components.json | tr -d '"') 
  
    DIR=$(yq ".plugintypes.$TYPE" "$RACINE"/components.yml)
    if [[ $DIR == 'null' ]];
      then error=1 && error "Prefixe $TYPE unkown" exit 1    
    fi

    if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; 
    then
      cd "$MOODLE_SRC" || exit 1
      # git subrepo clean "$DIR"/"$NOM"
      # [ $? -ne 0 ] && error=1 &&  echo "$red error git subrepo clean ${DIR}/${NOM} $black"  
      git rm -r  "$MOODLE_SRC"/"$DIR"/"$NOM"
      [ $? -ne 0 ] && error=1 &&  echo "git rm -r $DIR/$NOM} "  
      git commit -m "Suppress plugin $PLUGIN" --quiet
      [ $? -ne 0 ] && error=1 &&  error "Error git commit" 
      success "$PLUGIN deleted in codebase"  
      echo -e "Press any key \n"
      read -rn 1 c
      sortie=0
    else
      warn "Plugin $PLUGIN not present nothing to do!"     
    fi
  else
   echo "Abandon !"  
  fi

info End "$FUNCNAME"
}

pluginslist () {
  info Start  "$FUNCNAME"
  error=0
  PLUGINS=$(yq 'select(.plugins) |.plugins| keys' "$PROJECTS_PATH_PROJECT"/"$PROJECT".yml)
  [ "$DEBUG" = true ] && echo PLUGINS $PLUGINS
  for PLUGIN in $PLUGINS; do
    echo "Check plugin: $PLUGIN"
    [[ "$PLUGIN" =~ ^\-.* ]] && continue

    PLUGIN=$(whiptail --title "Suppression d'une version" --menu "$CURRENT" 20 100 "$ARLENGTH" "$LIST[@]" 3>&1 1>&2 2>&3)
    exitstatus=$?
    if [ $exitstatus = 0 ]; then 
      #PLUGIN=$(whiptail --title "ADELE ${PROJECT}" --inputbox "PLUGIN ? " 10 60 "${PLUGINSAVE}" 3>&1 1>&2 2>&3)
      echo " Suppression du plugin ${PLUGIN}"         
      if (whiptail --title "Boite de dialogue Oui / Non" --yesno "Suppression du plugin ${PLUGIN}" 10 60) then
        set_plugin "$PROJECT" "$PLUGIN"
        if [ -d "$MOODLE_SRC"/"$DIR"/"$NOM" ]; then        
          cd "$MOODLE_SRC" || exit 1
          success "Plugin ${NOM} exists in $DIR" 
          # git subrepo clean "$DIR"/"$NOM"
          # [ $? -ne 0 ] && error=1 &&  echo "$red error git subrepo clean ${DIR}/${NOM} $black"  
          git rm -r  "$DIR"/"$NOM"
          [ $? -ne 0 ] && error=1 &&  echo "git rm -r $DIR/$NOM} "  
          git commit -m "Suppression du plugin $PLUGIN"  
          [ $? -ne 0 ] && error=1 &&  error "Error git commit" 
          success "$PLUGIN deleted in codebase"  
   
          echo -e "Press any key \n"
          read -rn 1 c
          sortie=0
        else
          echo "Plugin $PLUGIN n'est pas installé!"
          sortie=1
        fi
      else
       echo "Abandon !"  
      fi
    else
      echo "Annulé!"
    fi 
  done 
  info End "$FUNCNAME"
}

 nothingtodo () {
  error=0
  export sortie
  echo 'nothing to do..'
  sortie=0
  echo -e "Press any key \n"
  read -nr 1 c
 }

help () {
  info Start  "$FUNCNAME"
  pandoc -s -f markdown -t man README.md | groff -T utf8 -man | less
  info End "$FUNCNAME"
}